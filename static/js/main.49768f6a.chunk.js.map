{"version":3,"sources":["state/reducer.js","components/Store.jsx","components/VideoSquare/InputOutputSelect.jsx","components/VideoSquare/AudioVideoSetup.jsx","components/VideoSquare/index.jsx","components/GreenRoom.jsx","state/use-previous.js","components/App.js","serviceWorker.js","index.js"],"names":["initialState","myId","myStream","order","peers","server","streams","videoElement","reducer","state","action","console","log","type","id","oldStream","newStream","stream","Object","values","forEach","peer","removeStream","addStream","replacePeerStreams","data","dispatch","JSON","parse","forId","theirId","fromId","receiveSignal","signal","initiator","isNewPeer","keys","includes","Peer","on","send","stringify","theirStream","handleServerMessage","error","Context","createContext","Store","children","useReducer","Provider","value","InputOutputSelect","useContext","useState","devices","setDevices","showSetup","setShowSetup","audioInput","setAudioInput","audioOutput","setAudioOutput","videoInput","setVideoInput","setStream","a","getTracks","track","stop","navigator","mediaDevices","getUserMedia","audio","autoGainControl","exact","deviceId","echoCancellation","noiseSuppression","video","AudioContext","window","webkitAudioContext","audioCtx","createMediaStreamSource","connect","destination","useEffect","enumerateDevices","deviceList","findDevices","setSinkId","kinds","kindLabels","selectedDevices","devicesSorted","reduce","accumulator","device","kind","index","indexOf","slice","map","deviceMap","label","selectedDeviceId","setSelectedDeviceId","key","onChange","event","target","onClick","AudioVideoSetup","showWelcome","setShowWelcome","welcomeMessage","style","alignItems","display","flexDirection","bottom","justifyContent","position","width","VideoSquare","isMe","videoRef","useCallback","node","srcObject","src","URL","createObjectURL","number","findIndex","otherId","autoPlay","muted","ref","left","top","GreenRoom","prevMyStream","prevRef","useRef","current","usePrevious","serverURL","URLSearchParams","location","search","get","WebSocket","addEventListener","className","entries","App","Boolean","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.49768f6a.chunk.js","sourcesContent":["import Peer from 'simple-peer';\n\nexport const initialState = {\n    myId         : null,\n    myStream     : null,\n    order        : [],\n    peers        : {},\n    server       : null,\n    streams      : {},\n    videoElement : null\n};\n\nfunction replacePeerStreams(state, action) {\n    const { myStream : oldStream, peers } = state;\n    const { stream : newStream } = action;\n    Object.values(peers).forEach((peer) => {\n        peer.removeStream(oldStream)\n        peer.addStream(newStream);\n    });\n}\n\nfunction handleServerMessage(state, action) {\n    const { myStream, peers, server } = state;\n    // Sending dispatch in the action is kind of a hack...\n    const { data, dispatch } = action;\n    const {\n        forId  : myId,\n        fromId : theirId,\n        order,\n        signal : receiveSignal,\n        type\n    } = JSON.parse(data);\n    if (type === 'id') {\n        dispatch({\n            type : 'MY_ID_SET',\n            id   : myId,\n        });\n    } else if (type === 'order') {\n        dispatch({\n            type : 'ORDER_SET',\n            order\n        });\n    } else if (type === 'signal') {\n        const initiator = receiveSignal === 'initiate';\n        const isNewPeer = !Object.keys(peers).includes(theirId);\n        const peer = isNewPeer ?\n            new Peer({\n                initiator,\n                stream : myStream,\n            }) :\n            peers[theirId];\n        if (isNewPeer) {\n            peer.on('signal', (signal) => {\n                server.send(JSON.stringify({\n                    type   : 'signal',\n                    forId  : theirId,\n                    fromId : myId,\n                    signal\n                }));\n            });\n            peer.on('stream', (theirStream) => {\n                dispatch({\n                    type   : 'STREAMS_ADD',\n                    id     : theirId,\n                    stream : theirStream\n                });\n            });\n        }\n\n        if (!initiator) {\n            peer.signal(receiveSignal);\n        }\n\n        if (isNewPeer) {\n            return {\n                ...state,\n                peers : {\n                    ...peers,\n                    [theirId] : peer\n                }\n            };\n        }\n    }\n\n    return state;\n}\n\n// This reducer is not quite a pure function and I'm not sorry about it.\n// The SERVER_MESSAGE action will sometimes not mutate state but just call peer.signal().\n// Basically I'm hijacking the reducer to get the current state\n// when a message is received from the server.\nexport default function reducer(state, action) {\n    console.log('ACTION', action);\n    const { streams } = state;\n    switch (action.type) {\n        case 'MY_ID_SET':\n            return {\n                ...state,\n                myId : action.id\n            };\n        case 'MY_STREAM_SET': {\n            replacePeerStreams(state, action);\n            return {\n                ...state,\n                myStream : action.stream\n            };\n        }\n        case 'ORDER_SET':\n            return {\n                ...state,\n                order : action.order\n            };\n        case 'SERVER_MESSAGE':\n            return handleServerMessage(state, action)\n        case 'SERVER_SET':\n            return {\n                ...state,\n                server : action.server\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams : {\n                    ...streams,\n                    // This ID matches the peer ID\n                    [action.id] : action.stream,\n                }\n            };\n        case 'VIDEO_ELEMENT_SET':\n            return {\n                ...state,\n                videoElement : action.videoElement\n            };\n        default: {\n            console.error('Unknown action:', action);\n            return state;\n        }\n    }\n};\n","import React, { createContext, useReducer } from 'react';\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\n\nconst InputOutputSelect = () => {\n    const [state, dispatch] = useContext(Context);\n    const { myStream, videoElement } = state;\n    const [devices, setDevices] = useState([]);\n    const [showSetup, setShowSetup] = useState(true);\n    const [audioInput, setAudioInput] = useState(null);\n    const [audioOutput, setAudioOutput] = useState(null);\n    const [videoInput, setVideoInput] = useState(null);\n\n    const setStream = async () => {\n        if (myStream) {\n            myStream.getTracks().forEach((track) => track.stop());\n        }\n        const stream = await navigator.mediaDevices.getUserMedia({\n            audio : {\n                autoGainControl  : { exact : false },\n                deviceId         : audioInput && {\n                    exact : audioInput\n                },\n                echoCancellation : false,\n                noiseSuppression : { exact : false },\n            },\n            video : {\n                deviceId : videoInput && {\n                    exact : videoInput\n                }\n            }\n        });\n        // Safari, what the hell.\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioCtx = new AudioContext();\n        const source = audioCtx.createMediaStreamSource(stream);\n        source.connect(audioCtx.destination);\n        dispatch({\n            type : 'MY_STREAM_SET',\n            stream\n        });\n    };\n\n    useEffect(() => {\n        // On Safari, enumerateDevices only works after getUserMedia is called.\n        // So wait for that to happen before populating the dropdowns.\n        // (Also, missing things even after it's called...)\n        if (myStream) {\n            const findDevices = async () => {\n                const deviceList = await navigator.mediaDevices.enumerateDevices();\n                setDevices(deviceList);\n            };\n            findDevices();\n        }\n    }, [myStream]);\n\n    useEffect(() => {\n        // Called on the first render\n        // (and any time audioInput or videoInput change)\n        setStream();\n    }, [audioInput, videoInput]);\n\n    useEffect(() => {\n        if (videoElement && audioOutput) {\n            videoElement.setSinkId(audioOutput);\n        }\n    }, [audioOutput, videoElement]);\n\n    const kinds = ['audioinput', 'audiooutput', 'videoinput'];\n    const kindLabels = ['Audio Input', 'Audio Output', 'Video Input'];\n    const selectedDevices = [\n        [audioInput, setAudioInput],\n        [audioOutput, setAudioOutput],\n        [videoInput, setVideoInput]\n    ];\n    // Sort the available devices into the three buckets\n    const devicesSorted = devices.reduce((accumulator, device) => {\n        const { deviceId, kind } = device;\n        const index = kinds.indexOf(kind);\n        return [\n            ...accumulator.slice(0, index),\n            {\n                ...accumulator[index],\n                [deviceId] : device,\n            },\n            ...accumulator.slice(index + 1)\n        ]\n    }, [{}, {}, {}]);\n\n    return showSetup ? <>\n        { devicesSorted.map((deviceMap, index) => {\n            const label = kindLabels[index];\n            const [selectedDeviceId, setSelectedDeviceId] = selectedDevices[index];\n            return (\n                <label key={label}>\n                    {label}\n                    <select\n                        onChange={(event) => setSelectedDeviceId(event.target.value)}\n                        value={selectedDeviceId || 'default'}\n                    >\n                        { Object.values(deviceMap).map(({ deviceId, label }) => (\n                            <option key={deviceId} value={deviceId}>{label}</option>\n                        )) }\n                    </select>\n                </label>\n            );\n        }) }\n        <button onClick={() => setShowSetup(false)}>x</button>\n    </> :\n    <button onClick={() => setShowSetup(true)}>Audio/Video settings</button>;\n};\n\nexport default InputOutputSelect;\n","import React, { useState } from 'react';\nimport InputOutputSelect from './InputOutputSelect';\n\nconst AudioVideoSetup = () => {\n    const [showWelcome, setShowWelcome] = useState(true);\n\n    const welcomeMessage = <>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video. Before you click the button, put on headphones so there's no feedback!</div>\n        <button onClick={() => setShowWelcome(false)}>\n            Let's go!\n        </button>\n    </>;\n\n    const style = {\n        alignItems    : 'center',\n        display       : 'flex',\n        flexDirection : showWelcome ? 'column' : 'row'\n    };\n\n    if (!showWelcome) {\n        style.bottom = '0';\n        style.justifyContent = 'space-between';\n        style.position = 'absolute';\n        style.width = '100%';\n    }\n\n    return (\n        <section style={style}>\n            { showWelcome ?\n                welcomeMessage :\n                <InputOutputSelect /> }\n        </section>\n    );\n};\n\nexport default AudioVideoSetup;\n","import React, { useCallback, useContext } from 'react';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport { Context } from '../Store';\n\nconst VideoSquare = ({ id, isMe, stream }) => {\n    const [state, dispatch] = useContext(Context);\n    const { order } = state;\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if ('srcObject' in node) {\n                node.srcObject = stream;\n            } else {\n                node.src = URL.createObjectURL(stream);\n            }\n            // The video element must be available elsewhere\n            // to set audio output via setSinkId().\n            if (isMe) {\n                dispatch({\n                    type         : 'VIDEO_ELEMENT_SET',\n                    videoElement : node\n                });\n            }\n        }\n    }, [stream]);\n\n    const number = order.findIndex((otherId) => id === otherId) + 1;\n    const style = {\n        order    : number,\n        position : 'relative'\n    };\n    if (isMe) {\n        style.display = 'flex';\n        style.flexDirection = 'column';\n    }\n    const numberStyle = {\n        left     : 0,\n        position : 'absolute',\n        top      : 0\n    };\n\n    return (\n        <div style={style}>\n            { stream && <video autoPlay muted={isMe} ref={videoRef} /> }\n            { isMe && <AudioVideoSetup /> }\n            { stream && <span style={numberStyle}>{number}</span> }\n        </div>\n    );\n};\n\nexport default VideoSquare;\n","import React, { useContext, useEffect } from 'react';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\nimport './GreenRoom.css';\nimport usePrevious from '../state/use-previous';\n\nconst GreenRoom = () => {\n    const [state, dispatch] = useContext(Context);\n    console.log('STATE', state);\n    const { myId, myStream, streams } = state;\n    const prevMyStream = usePrevious(myStream);\n\n    const params = new URLSearchParams(window.location.search);\n    const serverURL = params.get('server');\n    useEffect(() => {\n        // Start the server connection only when myStream is first initiated\n        if (myStream && !prevMyStream && serverURL) {\n            // We set the server connection here because\n            // we need access to dispatch in the event listeners.\n            const server = new WebSocket(serverURL);\n            server.addEventListener('close', () => console.log('closing socket'));\n            server.addEventListener('error', () => console.log('socket error'));\n            server.addEventListener('open', () => console.log('opening socket'));\n            server.addEventListener('message', ({ data }) => {\n                dispatch({\n                    type : 'SERVER_MESSAGE',\n                    data,\n                    dispatch\n                });\n            });\n            dispatch({\n                type : 'SERVER_SET',\n                server\n            });\n            // TODO: handle failed connection\n        }\n    }, [myStream, prevMyStream, serverURL]);\n\n    if (!serverURL) {\n        return \"You have to have a server. Sorry, that's just the way it is.\";\n    }\n\n    return (\n        <main className=\"videos\">\n            <VideoSquare isMe id={myId} stream={myStream} />\n            { Object.entries(streams).map(([id, stream]) => {\n                return <VideoSquare key={id} id={id} stream={stream} />;\n            }) }\n        </main>\n    );\n};\n\nexport default GreenRoom;\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious(value) {\n    const prevRef = useRef();\n    useEffect(() => {\n        prevRef.current = value;\n    }, [value]);\n    return prevRef.current;\n}\n","import React from 'react';\nimport GreenRoom from './GreenRoom';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <GreenRoom />\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}