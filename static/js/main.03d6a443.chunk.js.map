{"version":3,"sources":["state/modes.js","state/actions/server.js","state/actions/peers.js","state/actions/recording.js","state/actions/cascade.js","state/reducer.js","components/Store.jsx","components/VideoSquare/AudioVideoSetup.jsx","components/VideoSquare/Countdown.jsx","state/use-previous.js","components/VideoSquare/index.jsx","components/Welcome.jsx","components/GreenRoom.jsx","components/ServerProvider.jsx","components/App.js","serviceWorker.js","index.js"],"names":["READY","CASCADE_DONE","serverSend","sendAction","getState","server","send","JSON","stringify","makeServer","serverURL","dispatch","WebSocket","addEventListener","console","log","data","action","parse","type","changeMode","mode","newOrder","order","myId","oldOrder","peers","length","forEach","id","makeNewPeer","checkForNewPeers","fromId","signal","handlePeerSignal","startTime","forId","latencies","serverLatencies","push","Date","now","addServerLatency","handleServerPingPong","setInterval","initiator","newId","myStream","peer","Peer","stream","on","theirStream","cascadeReceiveTime","cascade","audioTracks","getAudioTracks","videoTracks","getVideoTracks","myIndex","indexOf","slice","index","tracks","filter","Boolean","error","MediaStream","setStreamsFromCascade","streams","addStream","cloneMyStream","remoteStartTime","toString","peerRelativeOneWayLatencies","peerRoundTripLatencies","addPeerRoundTripLatency","pingPeer","getNextPeer","state","nextIndex","cloneTracks","getTracks","map","track","clone","newMode","recorder","cascadeStandbyTime","Object","values","removeStream","stopStreaming","iAmInitiator","nextPeer","gatherLatencyInfo","cascadeRecordingTime","myTracks","otherTracks","reduce","accumulator","cascadeStream","cascadeSendTime","sendCascadeStream","start","stop","newMyStream","resetStreams","makeNewRecorder","MediaRecorder","mimeType","file","URL","createObjectURL","beforeRecordLatency","latencyInfo","peerPongNum","peerPongTimeAvg","avg","peerPongTimeStdDev","stddev","sendLatency","entries","serverPongNum","serverPongTimeAvg","serverPongTimeStdDev","peerPingNum","peerPingTimeAvg","peerPingTimeStdDev","signalingLatency","sendLatencyInfo","value","mean","sumOfSquares","Math","pow","sqrt","initialState","audioOutput","files","evilBoogiemanGlobalState","reduceAndSave","newState","deviceId","concat","newStreams","findIndex","otherId","newPeers","reducer","Context","createContext","Store","children","useReducer","Provider","audioCtx","window","AudioContext","webkitAudioContext","AudioVideoSetup","useContext","useState","devices","setDevices","showSetup","setShowSetup","audioInput","setAudioInput","videoInput","setVideoInput","setStream","a","navigator","mediaDevices","getUserMedia","audio","exact","autoGainControl","echoCancellation","noiseSuppression","video","createMediaStreamSource","connect","destination","useEffect","enumerateDevices","deviceList","findDevices","kinds","kindLabels","selectedDevices","devicesSorted","device","kind","className","deviceMap","devicesOfType","label","selectedDeviceId","setSelectedDeviceId","key","onChange","event","target","onClick","Countdown","number","setNumber","setTimeout","CASCADE_STANDBY_DURATION","usePrevious","prevRef","useRef","current","VideoSquare","numColumns","isMe","prevStream","prevAudioOutput","videoRef","useCallback","node","srcObject","src","setSinkId","dndRef","useDrag","item","canDrag","includes","collect","monitor","isDragging","connectDrag","useDrop","accept","drop","hover","hoveredOverId","theirIndex","connectDrop","orderNumber","row","ceil","gridStyle","gridColumn","gridRow","opacity","orderNumberStyle","backgroundColor","ref","style","autoPlay","muted","Welcome","GreenRoom","showWelcome","setShowWelcome","numParticipants","cols","rows","colPct","rowPct","gridStyles","gridTemplateColumns","gridTemplateRows","startCascade","stopCascade","blobURL","download","href","ServerProvider","prevMyStream","URLSearchParams","location","search","get","App","DndProvider","backend","HTML5Backend","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.03d6a443.chunk.js","sourcesContent":["// User is connecting audio/video, hasn't connected to server\nexport const SETUP = 0;\n// Connected to server, waiting for initiator to press GO\nexport const READY = 1;\n// Cascade has started but recording hasn't started yet.\n// For initiator, there's a short countdown.\n// For everyone else, it's just waiting on the stream to arrive.\nexport const CASCADE_STANDBY = 2;\n// Cascade in progress!\n// This will end for the initiator when they press the DONE button\n// and for everyone else when the stream ends.\nexport const CASCADE_RECORDING = 3;\n// After the cascade is finished, restarting connections needs to be handled differently.\n// Upstream peers should only send their video downstream after the downstream peers have finished.\nexport const CASCADE_DONE = 4;\n","import { changeMode } from './cascade';\nimport { checkForNewPeers, handlePeerSignal } from './peers';\nimport { handleServerPingPong } from './recording';\nimport { getState } from '../reducer';\n\nexport function serverSend(sendAction) {\n    const { server } = getState();\n    server.send(JSON.stringify(sendAction));\n}\n\nexport function makeServer(serverURL, dispatch) {\n    // We set the server connection here because\n    // we need access to dispatch in the event listeners.\n    const server = new WebSocket(serverURL);\n    server.addEventListener('open', () => console.log('opening socket'));\n    // TODO: handle failed connection\n    server.addEventListener('close', () => console.log('closing socket'));\n    server.addEventListener('error', () => console.log('socket error'));\n    server.addEventListener('message', ({ data }) => {\n        const action = JSON.parse(data);\n        console.log('ACTION (from server):', action);\n        // Some actions have side effects and should only happen once.\n        // (a single dispatch can call the reducer multiple times)\n        switch (action.type) {\n            case 'MODE_SET':\n                changeMode(action.mode, dispatch);\n                break;\n            case 'ORDER_SET':\n                checkForNewPeers(action, dispatch);\n                break;\n            case 'PEER_SIGNAL':\n                handlePeerSignal(action, dispatch);\n                break;\n            case 'ping':\n            case 'pong':\n                handleServerPingPong(action);\n                break;\n            default:\n                // Otherwise, messages from the server\n                // are simply actions for the reducer.\n                dispatch(action);\n        }\n    });\n    setInterval(() => {\n        // Keep the connection alive\n        serverSend({ type : 'ping' });\n    }, 30000);\n    dispatch({\n        type : 'SERVER_SET',\n        server\n    });\n}\n","import Peer from 'simple-peer';\nimport { changeMode, cloneMyStream, setStreamsFromCascade } from './cascade';\nimport { addPeerRelativeOneWayLatency, addPeerRoundTripLatency, setCascadeReceiveTime } from './recording';\nimport { serverSend } from './server';\nimport { CASCADE_DONE, CASCADE_RECORDING, CASCADE_STANDBY } from '../modes';\nimport { getState } from '../reducer';\n\nexport function checkForNewPeers(action, dispatch) {\n    const { order : newOrder } = action;\n    const { myId, order : oldOrder, peers } = getState();\n    dispatch(action);\n    // If receiving order for the first time,\n    // initialize a new peer for everyone else waiting\n    if (oldOrder.length === 0) {\n        newOrder.forEach((id) => {\n            if (id !== myId && !peers[id]) {\n                makeNewPeer(true, id, dispatch);\n            }\n        });\n    }\n}\n\nfunction makeNewPeer(initiator, newId, dispatch) {\n    const { myId, myStream } = getState();\n    const peer = new Peer({\n        initiator,\n        stream : myStream,\n    });\n\n    peer.on('signal', (signal) => {\n        serverSend({\n            type   : 'PEER_SIGNAL',\n            forId  : newId,\n            fromId : myId,\n            signal\n        });\n    });\n\n    peer.on('stream', (theirStream) => {\n        const { mode } = getState();\n        // In this mode, the stream is a cascade\n        // containing all the synchronized audio/video\n        // from all previous peers.\n        // Receiving it is a signal to start the cascade.\n        if (mode === CASCADE_STANDBY) {\n            setCascadeReceiveTime();\n            setStreamsFromCascade(theirStream, dispatch);\n            changeMode(CASCADE_RECORDING, dispatch);\n        } else {\n            dispatch({\n                type   : 'STREAMS_ADD',\n                id     : newId,\n                stream : theirStream\n            });\n            // If a new stream is added while recording,\n            // that means the cascade is over\n            if (mode === CASCADE_RECORDING) {\n                changeMode(CASCADE_DONE, dispatch);\n            }\n            // After cascading, if this is sent from downstream,\n            // we need to reciprocate and reopen our stream as well\n            if (mode === CASCADE_DONE && peer.streams.length === 0) {\n                peer.addStream(cloneMyStream());\n            }\n        }\n    });\n\n    // The peer data channel is currently only used for sending\n    // pings to get an idea of the time it takes for a stream\n    // to reach the next person in the cascade\n    peer.on('data', (data) => {\n        const { mode } = getState();\n        const { startTime, type } = JSON.parse(data.toString());\n\n        // Send the ping right back\n        if (type === 'ping') {\n            addPeerRelativeOneWayLatency(startTime)\n            peer.send(JSON.stringify({\n                type : 'pong',\n                startTime,\n            }));\n        }\n        if (type === 'pong') {\n            addPeerRoundTripLatency(startTime)\n            // Keep pinging until recording starts\n            if (mode === CASCADE_STANDBY) {\n                pingPeer(peer);\n            }\n        }\n    });\n\n    dispatch({\n        type : 'PEERS_ADD',\n        id   : newId,\n        peer\n    });\n    return peer;\n}\n\nexport function handlePeerSignal(action, dispatch) {\n    const { peers } = getState();\n    const { fromId, signal } = action;\n    const existingPeer = peers[fromId];\n    const peer = existingPeer || makeNewPeer(false, fromId, dispatch);\n    peer.signal(signal);\n}\n\nexport function getNextPeer(state) {\n    const { myId, order, peers } = getState();\n    const nextIndex = order.indexOf(myId) + 1;\n    const nextId = order[nextIndex];\n    return peers[nextId];\n}\n\nexport function pingPeer(peer) {\n    peer.send(JSON.stringify({\n        type      : 'ping',\n        startTime : Date.now()\n    }));\n}\n","import { CASCADE_STANDBY_DURATION } from './cascade';\nimport { getNextPeer, pingPeer } from './peers';\nimport { serverSend } from './server';\nimport { CASCADE_STANDBY } from '../modes';\nimport { getState } from '../reducer';\n\nexport function makeNewRecorder(stream, dispatch) {\n    // TODO: use specific codecs. check browser compatibility.\n    const recorder = new MediaRecorder(stream, { mimeType : 'video/webm' });\n    recorder.addEventListener('dataavailable', ({ data }) => {\n        dispatch({\n            type : 'FILES_ADD',\n            file : URL.createObjectURL(data),\n        });\n    });\n    recorder.addEventListener('start', () => {\n        const { iAmInitiator } = getState();\n        // For non-initiators, there could be an additional delay between\n        // receiving the stream and record start.\n        const startTime = iAmInitiator ? cascadeRecordingTime : cascadeReceiveTime;\n        beforeRecordLatency = Date.now() - startTime;\n    });\n    recorder.addEventListener('stop', () => {\n        sendLatencyInfo();\n    })\n    return recorder;\n}\n\n// The time it takes for a ping to get back to its sender\nlet peerRoundTripLatencies = [];\nexport function addPeerRoundTripLatency(startTime) {\n    peerRoundTripLatencies.push(Date.now() - startTime);\n}\n\n// The difference between the time at the sender and the local time when it's received.\n// We can compare this value with an estimated one-way trip time\n// to see the time offset between the two machines (hopefully).\nlet peerRelativeOneWayLatencies = [];\nexport function addPeerRelativeOneWayLatency(remoteStartTime) {\n    peerRelativeOneWayLatencies.push(Date.now() - remoteStartTime);\n}\n\nlet serverLatencies = {};\nfunction addServerLatency(id, startTime) {\n    const latencies = serverLatencies[id] || [];\n    if (latencies.length === 0) {\n        serverLatencies[id] = latencies;\n    }\n    latencies.push(Date.now() - startTime);\n}\n\n// The time CASCADE_STANDBY starts\nlet cascadeStandbyTime;\nexport function setCascadeStandbyTime() {\n    cascadeStandbyTime = Date.now();\n}\n\n// When the cascade stream is received\n// (not relevant for the initiator)\nlet cascadeReceiveTime;\nexport function setCascadeReceiveTime() {\n    cascadeReceiveTime = Date.now();\n}\n\n// The time CASCADE_RECORDING starts\nlet cascadeRecordingTime;\nexport function setCascadeRecordingTime() {\n    cascadeRecordingTime = Date.now();\n}\n\n// Right after the stream is sent, to see how long that part takes.\nlet cascadeSendTime;\nexport function setCascadeSendTime() {\n    cascadeSendTime = Date.now();\n}\n\nlet beforeRecordLatency;\n\n// This starts a series of pings that lasts from standby until recording starts\n// to get an idea of the latencies between each connection in the cascade.\n// We use it later to stitch together the video.\nexport function gatherLatencyInfo() {\n    const { iAmInitiator, myId } = getState();\n    const nextPeer = getNextPeer();\n    // Peer latencies\n    if (nextPeer) {\n        pingPeer(nextPeer);\n    }\n    // Server latencies\n    if (iAmInitiator) {\n        // This will broadcast to all other peers\n        // because forId is missing\n        serverSend({\n            type      : 'ping',\n            fromId    : myId,\n            startTime : Date.now()\n        });\n    }\n}\n\nexport function handleServerPingPong(action) {\n    const { fromId, startTime, type } = action;\n    const { mode, myId } = getState();\n\n    // If it's a regular keep-alive pong from the server\n    // just ignore it\n    if (!fromId) return;\n\n    switch (type) {\n        case 'ping':\n            serverSend({\n                type   : 'pong',\n                forId  : fromId,\n                fromId : myId,\n                startTime,\n            });\n            break;\n        case 'pong':\n            addServerLatency(fromId, startTime);\n            // Keep pinging until recording starts\n            if (mode === CASCADE_STANDBY) {\n                serverSend({\n                    type      : 'ping',\n                    forId     : fromId,\n                    fromId    : myId,\n                    startTime : Date.now()\n                });\n            }\n            break;\n        default:\n    }\n}\n\nexport function sendLatencyInfo() {\n    const { iAmInitiator, myId } = getState();\n\n    let latencyInfo = {\n        type   : 'latency_info',\n        fromId : myId,\n        beforeRecordLatency,\n    };\n\n    // No pongs at the end of the cascade\n    if (getNextPeer()) {\n        const peerPongNum = peerRoundTripLatencies.length;\n        const peerPongTimeAvg = avg(peerRoundTripLatencies);\n        const peerPongTimeStdDev = stddev(peerRoundTripLatencies, peerPongTimeAvg);\n        const sendLatency = cascadeSendTime - cascadeRecordingTime;\n        latencyInfo = {\n            ...latencyInfo,\n            peerPongNum,\n            peerPongTimeAvg,\n            peerPongTimeStdDev,\n            sendLatency\n        };\n    }\n\n    // No pings for initiator\n    if (!iAmInitiator) {\n        const peerPingNum = peerRelativeOneWayLatencies.length;\n        const peerPingTimeAvg = avg(peerRelativeOneWayLatencies);\n        const peerPingTimeStdDev = stddev(peerRelativeOneWayLatencies, peerPingTimeAvg);\n        const signalingLatency = cascadeReceiveTime - cascadeStandbyTime - CASCADE_STANDBY_DURATION;\n        latencyInfo = {\n            ...latencyInfo,\n            peerPingNum,\n            peerPingTimeAvg,\n            peerPingTimeStdDev,\n            signalingLatency\n        };\n    } else {\n        Object.entries(serverLatencies).forEach(([fromId, latencies]) => {\n            const serverPongNum = latencies.length;\n            const serverPongTimeAvg = avg(peerRoundTripLatencies);\n            const serverPongTimeStdDev = stddev(peerRoundTripLatencies, serverPongTimeAvg);\n            serverSend({\n                type: 'latency_info',\n                fromId,\n                serverPongNum,\n                serverPongTimeAvg,\n                serverPongTimeStdDev\n            })\n        });\n    }\n\n    serverSend(latencyInfo);\n    peerRoundTripLatencies = [];\n    peerRelativeOneWayLatencies = [];\n    serverLatencies = {};\n}\n\nfunction avg(values) {\n    const sum = values.reduce((accumulator, value) => accumulator + value, 0);\n    return sum / values.length;\n}\n\nfunction stddev(values, mean) {\n    const sumOfSquares = values.reduce(\n        (accumulator, value) => accumulator + Math.pow(value - mean, 2),\n        0\n    );\n    return Math.sqrt(sumOfSquares / (values.length - 1));\n}\n","import { getNextPeer } from './peers';\nimport {\n    gatherLatencyInfo,\n    setCascadeStandbyTime,\n    setCascadeRecordingTime,\n    setCascadeSendTime\n} from './recording';\nimport { serverSend } from './server';\nimport { CASCADE_DONE, CASCADE_RECORDING, CASCADE_STANDBY } from '../modes';\nimport { getState } from '../reducer';\n\nexport const CASCADE_STANDBY_DURATION = 6000; // milliseconds\n\nfunction cloneTracks(stream) {\n    return stream.getTracks().map((track) => track.clone());\n}\n\nexport function cloneMyStream() {\n    const { myStream } = getState();\n    const tracks = cloneTracks(myStream);\n    return new MediaStream(tracks);\n}\n\nexport function startCascade(dispatch) {\n    const { myId } = getState();\n    // dispatch MODE_SET and broadcast via server\n    // (server will set lock on new participants)\n    const mode = CASCADE_STANDBY;\n    const action = {\n        type   : 'MODE_SET',\n        fromId : myId,\n        mode\n    };\n    changeMode(mode, dispatch);\n    serverSend(action);\n}\n\nexport function changeMode(newMode, dispatch) {\n    dispatch({\n        type : 'MODE_SET',\n        mode : newMode\n    });\n\n    const { recorder } = getState();\n\n    switch (newMode) {\n        case CASCADE_STANDBY:\n            setCascadeStandbyTime();\n            stopStreaming();\n            gatherLatencyInfo();\n            break;\n        case CASCADE_RECORDING:\n            setCascadeRecordingTime();\n            sendCascadeStream();\n            recorder.start();\n            break;\n        case CASCADE_DONE:\n            recorder.stop();\n            resetStreams();\n            break;\n        default:\n    }\n}\n\nfunction stopStreaming() {\n    const { peers } = getState();\n    Object.values(peers).forEach((peer) => {\n        peer.removeStream(peer.streams[0]);\n    });\n}\n\nfunction sendCascadeStream() {\n    const { myId, myStream, order, streams } = getState();\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        const myIndex = order.indexOf(myId);\n        const myTracks = cloneTracks(myStream);\n        const otherTracks = order.slice(0, myIndex).reduce((accumulator, id) => {\n            return [\n                ...accumulator,\n                ...streams[id].getTracks()\n            ];\n        }, []);\n        const tracks = [\n            ...otherTracks,\n            ...myTracks\n        ];\n        // TODO: how to provide order?\n        // Maybe could peer.addTrack() one by one in order?\n        // Is that guaranteed to be received in the same order?\n        // Will there be A/V sync issues?\n        // Let's keep it TODO til we absolutely need do.\n        const cascadeStream = new MediaStream(tracks);\n        nextPeer.addStream(cascadeStream);\n        setCascadeSendTime();\n    }\n}\n\nexport function setStreamsFromCascade(cascade, dispatch) {\n    const { myId, order } = getState();\n    const audioTracks = cascade.getAudioTracks();\n    const videoTracks = cascade.getVideoTracks();\n    const myIndex = order.indexOf(myId);\n    const beforeIds = order.slice(0, myIndex);\n    // For now, combine randomly\n    beforeIds.forEach((id, index) => {\n        const tracks = [\n            audioTracks[index],\n            videoTracks[index]\n        ].filter(Boolean);\n        if (tracks.length !== 2) {\n            console.error('Missing a track in the cascade');\n        }\n        dispatch({\n            type   : 'STREAMS_ADD',\n            id,\n            stream : new MediaStream(tracks)\n        });\n    });\n}\n\nfunction resetStreams() {\n    const { myId, order, peers } = getState();\n\n    // Adding the same MediaStream again causes an error\n    // so we have to clone the tracks\n    // and wrap them in a new MediaStream\n    const newMyStream = cloneMyStream();\n\n    // Signal to the next one it's done\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        nextPeer.removeStream(nextPeer.streams[0]);\n        nextPeer.addStream(newMyStream);\n    }\n\n    // Send live video back to everyone upstream\n    const myIndex = order.indexOf(myId);\n    const beforeIds = order.slice(0, myIndex);\n    beforeIds.forEach((id) => {\n        const peer = peers[id];\n        peer.addStream(newMyStream);\n    });\n}\n\nexport function stopCascade(dispatch) {\n    changeMode(CASCADE_DONE, dispatch);\n}\n","import { CASCADE_STANDBY, READY, SETUP } from './modes';\nimport { makeNewRecorder } from './actions/recording';\n\nexport const initialState = {\n    // This needs to be stored here so all video elements output sound to the same place.\n    audioOutput   : null,\n    // Blob URLs of the recorded myStream (not combined with other peers)\n    files         : [],\n    // The initiator is whoever is in the first spot.\n    // They have all the power. They get to rearrange the order of the cascade.\n    // And they press the big GO button.\n    iAmInitiator  : false,\n    mode          : SETUP,\n    // UUID generated by the server\n    myId          : null,\n    // MediaStream object containing audio/video\n    myStream      : null,\n    // The order of the participants - how the audios cascades\n    order         : [],\n    // Direct connections to other participants via WebRTC that provide the streams\n    // Keys are the server-generated IDs\n    peers         : {},\n    // Records myStream during cascade\n    recorder      : null,\n    // WebSocket server connection to send the initial WebRTC signals (and a biiiit more after)\n    server        : null,\n    // MediaStream objects for remote peers\n    // Keys are the server-generated IDs\n    streams       : {}\n};\n\nfunction reducer(state, action) {\n    console.log('ACTION', action);\n    const { files, mode, myId, myStream, peers, streams } = state;\n    switch (action.type) {\n        case 'AUDIO_OUTPUT_SET':\n            return {\n                ...state,\n                audioOutput : action.deviceId\n            };\n        case 'FILES_ADD':\n            return {\n                ...state,\n                files : files.concat(action.file)\n            };\n        case 'MODE_SET': {\n            const { mode : newMode } = action;\n            // When starting the cascade, remove the streams\n            // (which will be stopped shortly)\n            const newStreams = newMode === CASCADE_STANDBY ? {} : streams;\n            return {\n                ...state,\n                mode    : newMode,\n                streams : newStreams\n            };\n        }\n        case 'MY_ID_SET':\n            return {\n                ...state,\n                myId : action.id\n            };\n        case 'MY_STREAM_SET': {\n            // Move from setup mode when myStream is first set\n            const newMode = myStream ? mode : READY;\n            return {\n                ...state,\n                mode     : newMode,\n                myStream : action.stream,\n                recorder : makeNewRecorder(action.stream, action.dispatch)\n            };\n        }\n        case 'ORDER_SET': {\n            const { order : newOrder } = action;\n            const myOrderIndex = newOrder.findIndex((otherId) => myId === otherId);\n            const iAmInitiator = myOrderIndex === 0;\n            // If an id has been taken away from the order, remove the peers and streams\n            const [newPeers, newStreams] = newOrder.reduce((accumulator, id) => {\n                if (id === myId) return accumulator;\n                return [\n                    {\n                        ...accumulator[0],\n                        [id] : peers[id]\n                    },\n                    {\n                        ...accumulator[1],\n                        [id] : streams[id]\n                    }\n                ]\n            }, [{}, {}]);\n            return {\n                ...state,\n                iAmInitiator,\n                order   : newOrder,\n                peers   : newPeers,\n                streams : newStreams\n            };\n        }\n        case 'PEERS_ADD':\n            return {\n                ...state,\n                peers : {\n                    ...peers,\n                    [action.id] : action.peer\n                }\n            };\n        case 'SERVER_SET':\n            return {\n                ...state,\n                server : action.server\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams : {\n                    ...streams,\n                    [action.id] : action.stream\n                }\n            };\n        default: {\n            console.error('Unknown action:', action);\n            return state;\n        }\n    }\n};\n\nlet evilBoogiemanGlobalState = {};\nexport function getState() {\n    return evilBoogiemanGlobalState;\n}\n\nexport default function reduceAndSave(state, action) {\n    const newState = reducer(state, action);\n    evilBoogiemanGlobalState = newState;\n    return newState;\n}\n","import React, { createContext, useReducer } from 'react';\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\n\n// Safari, what the hell.\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nconst audioCtx = new AudioContext();\n\nconst AudioVideoSetup = () => {\n    const [state, dispatch] = useContext(Context);\n    const { audioOutput, myStream, peers } = state;\n    const [devices, setDevices] = useState([]);\n    const [showSetup, setShowSetup] = useState(false);\n    const [audioInput, setAudioInput] = useState(null);\n    const [videoInput, setVideoInput] = useState(null);\n    const setAudioOutput = (deviceId) => {\n        dispatch({\n            type : 'AUDIO_OUTPUT_SET',\n            deviceId\n        });\n    }\n\n    const setStream = async () => {\n        const stream = await navigator.mediaDevices.getUserMedia({\n            audio : {\n                deviceId         : audioInput && {\n                    exact : audioInput\n                },\n                // These cause latency\n                autoGainControl  : { exact : false },\n                echoCancellation : false,\n                noiseSuppression : { exact : false },\n            },\n            video : {\n                deviceId : videoInput && {\n                    exact : videoInput\n                }\n            }\n        });\n        if (myStream) {\n            myStream.getTracks().forEach((track) => track.stop());\n            Object.values(peers).forEach((peer) => {\n                peer.removeStream(myStream)\n                peer.addStream(stream);\n            });\n        }\n        // Strangely, there is a delay when hearing the audio via the video element.\n        // But the delay is noticeably shorter when using the Web Audio API...\n        // (But only in Chrome?)\n        const source = audioCtx.createMediaStreamSource(stream);\n        // TODO: set output properly. See:\n        // https://stackoverflow.com/questions/41863094/how-to-select-destination-output-device-using-web-audio-api\n        source.connect(audioCtx.destination);\n        dispatch({\n            type : 'MY_STREAM_SET',\n            // Need to dispatch in the recorder ondataavailable event listener\n            dispatch,\n            stream\n        });\n    };\n\n    useEffect(() => {\n        // On Safari, enumerateDevices only works after getUserMedia is called.\n        // So wait for that to happen before populating the dropdowns.\n        // (Also, missing things even after it's called...)\n        if (myStream && showSetup) {\n            const findDevices = async () => {\n                const deviceList = await navigator.mediaDevices.enumerateDevices();\n                setDevices(deviceList);\n            };\n            findDevices();\n        }\n    }, [myStream, showSetup]);\n\n    useEffect(() => {\n        // Called on the first render\n        // (and any time audioInput or videoInput change)\n        setStream();\n    }, [audioInput, videoInput]);\n\n    const kinds = ['audioinput', 'audiooutput', 'videoinput'];\n    const kindLabels = ['Audio Input', 'Audio Output', 'Video Input'];\n    const selectedDevices = [\n        [audioInput, setAudioInput],\n        [audioOutput, setAudioOutput],\n        [videoInput, setVideoInput]\n    ];\n    // Sort the available devices into the three buckets\n    const devicesSorted = devices.reduce((accumulator, device) => {\n        const { deviceId, kind } = device;\n        const index = kinds.indexOf(kind);\n        return [\n            ...accumulator.slice(0, index),\n            {\n                ...accumulator[index],\n                [deviceId] : device,\n            },\n            ...accumulator.slice(index + 1)\n        ]\n    }, [{}, {}, {}]);\n\n    return (\n        <section className=\"av-setup\">\n            { showSetup ? <>\n                { devicesSorted.map((deviceMap, index) => {\n                    const devicesOfType = Object.values(deviceMap);\n                    if (devicesOfType.length === 0) return null;\n                    const label = kindLabels[index];\n                    const [selectedDeviceId, setSelectedDeviceId] = selectedDevices[index];\n                    return (\n                        <label key={label}>\n                            {label}\n                            <select\n                                onChange={(event) => setSelectedDeviceId(event.target.value)}\n                                value={selectedDeviceId || 'default'}\n                            >\n                                { devicesOfType.map(({ deviceId, label }) => (\n                                    <option key={deviceId} value={deviceId}>{label}</option>\n                                )) }\n                            </select>\n                        </label>\n                    );\n                }) }\n                <button onClick={() => setShowSetup(false)}>x</button>\n            </> :\n            <button onClick={() => setShowSetup(true)}>Audio/Video settings</button> }\n        </section>\n    );\n};\n\nexport default AudioVideoSetup;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\nimport { CASCADE_STANDBY_DURATION, changeMode } from '../../state/actions/cascade';\nimport { CASCADE_RECORDING } from '../../state/modes';\n\nconst Countdown = () => {\n    // Counts down to zero from here\n    const countdownStart = 3;\n    const [, dispatch] = useContext(Context);\n    const [number, setNumber] = useState(countdownStart);\n    useEffect(() => {\n        if (number > 0) {\n            setTimeout(() => {\n                setNumber(number - 1);\n            }, CASCADE_STANDBY_DURATION / countdownStart);\n        } else {\n            changeMode(CASCADE_RECORDING, dispatch);\n        }\n    }, [number]);\n    return <span className=\"countdown\">{number}</span>\n};\n\nexport default Countdown;\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious(value) {\n    const prevRef = useRef();\n    useEffect(() => {\n        prevRef.current = value;\n    }, [value]);\n    return prevRef.current;\n}\n","import React, { useCallback, useContext, useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport Countdown from './Countdown';\nimport { Context } from '../Store';\nimport usePrevious from '../../state/use-previous';\nimport { CASCADE_DONE, CASCADE_RECORDING, CASCADE_STANDBY, READY } from '../../state/modes';\nimport { serverSend } from '../../state/actions/server';\n\nconst VideoSquare = ({ id, numColumns, stream }) => {\n    const [state, dispatch] = useContext(Context);\n    const { audioOutput, iAmInitiator, mode, myId, order } = state;\n    const isMe = id === myId;\n    const prevStream = usePrevious(stream);\n    const prevAudioOutput = usePrevious(audioOutput);\n\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if (stream !== prevStream) {\n                if ('srcObject' in node) {\n                    node.srcObject = stream;\n                } else {\n                    node.src = URL.createObjectURL(stream);\n                }\n            }\n\n            if (audioOutput && audioOutput !== prevAudioOutput) {\n                // TODO: check if available, alert user if not\n                // (Firefox needs setting enabled)\n                // (Safari is ?)\n                node.setSinkId(audioOutput);\n            }\n        }\n    }, [audioOutput, stream]);\n\n    const dndRef = useRef(null);\n    const [{ isDragging }, connectDrag] = useDrag({\n        item    : { id, type : 'participant' },\n        canDrag : () => iAmInitiator && [READY, CASCADE_DONE].includes(mode),\n        collect : (monitor) => ({ isDragging : monitor.isDragging() })\n    });\n    const [, connectDrop] = useDrop({\n        accept : 'participant',\n        drop   : (item) => {\n            serverSend({\n                type   : 'ORDER_SET',\n                fromId : myId,\n                order,\n            });\n        },\n        hover  : ({ id : hoveredOverId }) => {\n            if (hoveredOverId !== id) {\n                const myIndex = order.indexOf(id);\n                const theirIndex = order.indexOf(hoveredOverId);\n                const newOrder = [...order];\n                newOrder[myIndex] = hoveredOverId;\n                newOrder[theirIndex] = id;\n                dispatch({\n                    type  : 'ORDER_SET',\n                    order : newOrder\n                });\n            }\n        }\n    });\n    connectDrag(dndRef);\n    connectDrop(dndRef);\n\n    const orderNumber = mode === CASCADE_STANDBY ? 1 : order.indexOf(id) + 1;\n    const row = Math.ceil(orderNumber / numColumns);\n    const numBeforeRow = (row - 1) * numColumns;\n    const col = orderNumber - numBeforeRow;\n    const gridStyle = {\n        gridColumn : `${col} / span 1`,\n        gridRow    : `${row} / span 1`,\n        opacity    : isDragging ? 0.5 : 1,\n    };\n    const orderNumberStyle = {\n        backgroundColor : mode === CASCADE_STANDBY ? 'yellow' : (\n            mode === CASCADE_RECORDING ? 'red' : 'green'\n        )\n    };\n\n    return (\n        <div ref={dndRef} className=\"video-draggable\" style={gridStyle}>\n            { stream && <video autoPlay muted={isMe} ref={videoRef} /> }\n            { isMe && <AudioVideoSetup /> }\n            { orderNumber > 0 &&\n                <span className=\"order-number\" style={orderNumberStyle}>{orderNumber}</span> }\n            { mode === CASCADE_STANDBY && isMe && iAmInitiator &&\n                <Countdown /> }\n        </div>\n    );\n};\n\nexport default VideoSquare;\n","import React from 'react';\n\nconst Welcome = ({ onClick }) => {\n    return <>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video. Before you click the button, put on headphones so there's no feedback!</div>\n        <button onClick={onClick}>\n            Let's go!\n        </button>\n    </>;\n};\n\nexport default Welcome;\n","import React, { useContext, useState } from 'react';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\nimport Welcome from './Welcome';\nimport { startCascade, stopCascade } from '../state/actions/cascade';\nimport { CASCADE_DONE, CASCADE_RECORDING, READY } from '../state/modes';\n\nconst GreenRoom = () => {\n    const [state, dispatch] = useContext(Context);\n    console.log('STATE', state);\n    const { files, iAmInitiator, mode, myId, myStream, streams } = state;\n    const [showWelcome, setShowWelcome] = useState(true);\n\n    if (showWelcome) {\n        return <Welcome onClick={() => setShowWelcome(false)} />;\n    }\n\n    const numParticipants = Object.values(streams).length + 1;\n    // Add a new row when the number of participants exceeds the perfect square\n    // (2-4 partcipants have two columns, 5-9 have three columns, 10-16 have four columns, etc)\n    const cols = Math.ceil(Math.sqrt(numParticipants));\n    const rows = Math.ceil(numParticipants / cols);\n    const colPct = 100 / cols;\n    const rowPct = 100 / rows;\n    const gridStyles = {\n        gridTemplateColumns : `repeat(${cols}, ${colPct}%)`,\n        gridTemplateRows    : `repeat(${cols}, ${rowPct}%)`,\n    };\n\n    return <>\n        <main className=\"video-grid\" style={gridStyles}>\n            <VideoSquare id={myId} numColumns={cols} stream={myStream} />\n            { Object.entries(streams).map(([id, stream]) =>\n                <VideoSquare key={id} id={id} numColumns={cols} stream={stream} />\n            ) }\n        </main>\n        <nav>\n            { [READY, CASCADE_DONE].includes(mode) && iAmInitiator && numParticipants > 1 &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => startCascade(dispatch)}\n                >\n                    GO\n                </button> }\n            { mode === CASCADE_RECORDING && iAmInitiator &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => stopCascade(dispatch)}\n                >\n                    STOP\n                </button> }\n        </nav>\n        <aside>\n            { files.map((blobURL, index) =>\n                <a\n                    key={blobURL}\n                    download={`cascade${index + 1}.webm`}\n                    href={blobURL}\n                >\n                    Download cascade {index + 1} video\n                </a>) }\n        </aside>\n    </>;\n};\n\nexport default GreenRoom;\n","import { useContext, useEffect } from 'react';\nimport { Context } from './Store';\nimport usePrevious from '../state/use-previous';\nimport { makeServer } from '../state/actions/server';\n\nconst ServerProvider = ({ children }) => {\n    const [state, dispatch] = useContext(Context);\n    const { myStream } = state;\n    const prevMyStream = usePrevious(myStream);\n    const params = new URLSearchParams(window.location.search);\n    const serverURL = params.get('server');\n    useEffect(() => {\n        // Start the server connection only when myStream is first initiated\n        if (myStream && !prevMyStream && serverURL) {\n            makeServer(serverURL, dispatch);\n        }\n    }, [myStream, prevMyStream, serverURL]);\n\n    if (!serverURL) {\n        return \"You have to have a server. Sorry, that's just the way it is.\";\n    }\n\n    return children;\n};\n\nexport default ServerProvider;\n","import React from 'react';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport GreenRoom from './GreenRoom';\nimport ServerProvider from './ServerProvider';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <ServerProvider>\n                <DndProvider backend={HTML5Backend}>\n                    <GreenRoom />\n                </DndProvider>\n            </ServerProvider>\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}