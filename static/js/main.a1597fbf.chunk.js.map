{"version":3,"sources":["state/actions/recording.js","state/actions/server.js","state/actions/peers.js","state/actions/cascade.js","state/reducer.js","components/Store.jsx","components/FileList.jsx","components/Navigation.jsx","components/VideoSquare/AudioVideoSetup.jsx","components/VideoSquare/Countdown.jsx","state/use-previous.js","components/VideoSquare/Video.jsx","components/VideoSquare/index.jsx","components/VideoGrid.jsx","components/Welcome.jsx","components/GreenRoom.jsx","components/ServerProvider.jsx","components/App.js","serviceWorker.js","index.js"],"names":["recorder","recordStartTime","blipRecorder","blipRecordStartTime","firstBlipTime","serverSend","sendAction","getState","server","send","JSON","stringify","makeServer","serverURL","dispatch","WebSocket","addEventListener","console","log","data","action","parse","type","changeMode","mode","newOrder","order","myId","oldOrder","peers","streams","length","forEach","id","makeNewPeer","reduce","accumulator","includes","concat","cleanStream","destroy","handleOrderSet","fromId","signal","handlePeerSignal","setInterval","_audioCtx","blipTimes","makeRecorder","stream","MediaRecorder","mimeType","stop","a","Date","now","makeBlipRecorder","audioCtx","AudioContext","window","webkitAudioContext","blipCount","listenToBlips","blipSourceNode","blipStream","createMediaStreamDestination","connect","iAmLast","analyzer","createAnalyser","fftSize","destination","freqResolution","sampleRate","timeResolution","Math","floor","freqBins","Uint8Array","frequencyBinCount","blipBin","doubleBlipBin","blipFreq","firstBlip","recordBlipTimes","blippin","analyzerIntervalId","countdown","CASCADE_DONE","clearInterval","disconnect","getByteFrequencyData","maxEnergyIndex","currentMaxIndex","energy","index","currentMaxEnergy","push","initiatorId","blipBinDistance","abs","CASCADE_STANDBY","initialState","start","CASCADE_RECORDING","initiator","peerId","myStream","sendStream","clone","peer","Peer","_sendStreams","on","forId","theirStream","nextPeer","getNextPeer","hasBlips","getUpstreamIds","slice","reverse","find","upstreamId","addStream","createMediaStreamSource","connectBlipListener","myIndex","indexOf","prevId","prevStream","addCascadedStream","toString","error","popStream","pop","removeStream","READY","nextIndex","getTracks","track","newMode","getDownstreamIds","setupCascade","cascadeModeSet","resetStreams","startCascade","blipDest","osc","createOscillator","frequency","value","blipper","createGain","gain","blipIntervalId","setValueAtTime","currentTime","sendBlips","audioOutput","files","iAmInitiator","evilBoogiemanGlobalState","reduceAndSave","state","newState","deviceId","fileName","blobURL","justPrevStream","newStreams","findIndex","otherId","newPeers","reducer","Context","createContext","Store","children","useReducer","Provider","FileList","useContext","map","key","download","href","Navigation","className","onClick","stopCascade","AudioVideoSetup","style","useState","devices","setDevices","showSetup","setShowSetup","audioInput","setAudioInput","videoInput","setVideoInput","useEffect","navigator","mediaDevices","enumerateDevices","deviceList","findDevices","getUserMedia","audio","exact","autoGainControl","echoCancellation","noiseSuppression","video","Object","values","setStream","kinds","kindLabels","selectedDevices","devicesSorted","device","kind","deviceMap","devicesOfType","label","selectedDeviceId","setSelectedDeviceId","onChange","event","target","Countdown","usePrevious","prevRef","useRef","current","Video","isMe","setVideoAspectRatio","prevAudioOutput","videoRef","useCallback","node","videoWidth","videoHeight","srcObject","src","URL","createObjectURL","setSinkId","autoPlay","ref","VideoSquare","col","orderNumber","numColumns","row","dndRef","useDrag","item","canDrag","collect","monitor","isDragging","connectDrag","useDrop","accept","drop","hover","hoveredOverId","theirIndex","connectDrop","gridColumn","gridRow","opacity","videoAspectRatio","left","setLeft","top","setTop","element","videoResizeObserver","ResizeObserver","entries","entry","contentRect","width","height","observe","showOrderNumber","orderNumberStyle","backgroundColor","settingsButtonStyle","right","VideoGrid","numParticipants","cols","ceil","sqrt","rows","colPct","rowPct","gridStyles","gridTemplateColumns","gridTemplateRows","getOrderProps","Welcome","GreenRoom","showWelcome","setShowWelcome","ServerProvider","prevMyStream","URLSearchParams","location","search","get","App","DndProvider","backend","HTML5Backend","Boolean","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.a1597fbf.chunk.js","sourcesContent":["import {\n    CASCADE_DONE,\n    CASCADE_RECORDING,\n    CASCADE_STANDBY,\n    changeMode,\n    getNextPeer\n} from './cascade';\nimport { addStream } from './peers';\nimport { serverSend } from './server';\nimport { getState, initialState } from '../reducer';\n\nlet recorder;\nlet recordStartTime;\nlet blipRecorder;\nlet blipRecordStartTime;\nlet firstBlipTime;\nlet blipTimes = [];\n\nexport function makeRecorder(stream, dispatch) {\n    // TODO: use specific codecs. check browser compatibility.\n    recorder = new MediaRecorder(stream, { mimeType : 'video/webm' });\n    recorder.addEventListener('dataavailable', ({ data }) => {\n        const { server } = getState();\n        console.log('SENDING VIDEO FILE TO SERVER');\n        server.send(data);\n        blipRecorder.stop();\n        // dispatch({\n        //     type     : 'FILES_ADD',\n        //     blobURL  : URL.createObjectURL(data),\n        //     fileName : `cascade${files.length + 1}_video${order.indexOf(myId) + 1}.webm`\n        // });\n    });\n    recorder.addEventListener('start', async () => {\n        recordStartTime = Date.now() - firstBlipTime;\n    });\n}\n\nfunction makeBlipRecorder(stream) {\n    blipRecorder = new MediaRecorder(stream, { mimeType : 'audio/webm' });\n    blipRecorder.addEventListener('dataavailable', ({ data }) => {\n        const { server } = getState();\n        console.log('SENDING METRONOME AUDIO TO SERVER');\n        server.send(data);\n        sendSyncInfo();\n    });\n    blipRecorder.addEventListener('start', async () => {\n        blipRecordStartTime = Date.now() - firstBlipTime;\n    });\n}\n\nexport function startRecording() {\n    recorder.start();\n    blipRecorder.start();\n}\n\nexport function stopRecording() {\n    recorder.stop();\n}\n\nexport function sendSyncInfo() {\n    const { myId } = getState();\n    serverSend({\n        type   : 'sync_info',\n        fromId : myId,\n        blipTimes,\n        blipRecordStartTime,\n        recordStartTime\n    });\n}\n\n// All the Web Audio API stuff below is to help match signals later.\n// When the initiator starts the cascade, it sends a series of blips.\n// Each peer in the cascade analyzes the incoming audio\n// and records when it detects a blip.\n\nlet _audioCtx;\nfunction audioCtx() {\n    if (!_audioCtx) {\n        // Safari, what the hell.\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        _audioCtx = new AudioContext();\n    }\n    return _audioCtx;\n}\n\nconst blipFreq = 440;\nconst doubleBlipFreq = blipFreq * 4;\nlet blipCount = -1;\nexport function sendBlips(dispatch) {\n    console.log(\"SENDING BLIPS\");\n    const blipDest = audioCtx().createMediaStreamDestination();\n    const blipStream = blipDest.stream;\n    const nextPeer = getNextPeer();\n    addStream(nextPeer, blipStream);\n\n    const gainValue = 0.1;\n    const blipLength = 0.1; // seconds\n    const osc = audioCtx().createOscillator();\n    osc.frequency.value = blipFreq;\n    // Connect oscillator to gain node\n    const blipper = audioCtx().createGain();\n    blipper.gain.value = 0;\n    osc.connect(blipper);\n    // Send blips to the analyzer for blip tracking\n    listenToBlips(blipper, dispatch);\n    // And send blips down the cascade\n    blipper.connect(blipDest);\n    osc.start();\n\n    // How to make a blip: turn the oscillator gain on and off\n    const makeBlip = () => {\n        const { mode } = getState();\n        if (mode === CASCADE_DONE) {\n            osc.stop();\n            window.clearInterval(blipIntervalId);\n            blipCount = -1;\n            return;\n        }\n        if (blipCount !== -1) {\n            // Send out a blip an octave higher every 4 blips\n            // to signal record start\n            if (blipCount % 4 === 0) {\n                osc.frequency.setValueAtTime(doubleBlipFreq, audioCtx().currentTime);\n                osc.frequency.setValueAtTime(blipFreq, audioCtx().currentTime + blipLength);\n            }\n            blipCount += 1;\n        }\n        blipper.gain.setValueAtTime(gainValue, audioCtx().currentTime);\n        blipper.gain.setValueAtTime(0, audioCtx().currentTime + blipLength);\n    };\n\n    const bpm = 100;\n    const bps = bpm / 60; // beats per second\n    const beatInterval = 1000 / bps; // ms between beats\n    const blipIntervalId = window.setInterval(makeBlip, beatInterval);\n}\n\nexport function sendRecordSignal() {\n    console.log(\"SENDING RECORD SIGNAL\");\n    // This signals to the makeBlip() function\n    // to start sending high blips every 4th blip\n    blipCount = 0;\n}\n\nexport function connectBlipListener(blipStream, dispatch) {\n    const blipSource = audioCtx().createMediaStreamSource(blipStream);\n    listenToBlips(blipSource, dispatch);\n}\n\nexport function listenToBlips(blipSourceNode, dispatch) {\n    console.log(\"LISTENING TO BLIPS\");\n\n    // Record blips, for experiments\n    const blipStream = audioCtx().createMediaStreamDestination();\n    blipSourceNode.connect(blipStream);\n    makeBlipRecorder(blipStream.stream);\n\n    const { myId, order, peers } = getState();\n    const iAmLast = order[order.length - 1] === myId;\n    const analyzer = audioCtx().createAnalyser();\n    analyzer.fftSize = 512;\n    blipSourceNode.connect(analyzer);\n    // Send blips to the speakers\n    analyzer.connect(audioCtx().destination);\n\n    const freqResolution = audioCtx().sampleRate / analyzer.fftSize;\n    const timeResolution = Math.floor(1 / freqResolution * 1000); // ms\n    const freqBins = new Uint8Array(analyzer.frequencyBinCount);\n    const blipBin = Math.floor(blipFreq / freqResolution);\n    const doubleBlipBin = Math.floor(doubleBlipFreq / freqResolution);\n\n    let firstBlip = true;\n    let recordBlipTimes = false;\n    let blippin = false;\n    const analyzerIntervalId = setInterval(() => {\n        const { countdown, mode } = getState();\n        if (mode === CASCADE_DONE) {\n            clearInterval(analyzerIntervalId);\n            blipSourceNode.disconnect(analyzer);\n            return;\n        }\n\n        analyzer.getByteFrequencyData(freqBins);\n        // Get the index of the frequency bin with the highest energy\n        // maxEnergyIndex === -1 means silence, no energy\n        const maxEnergyIndex = freqBins.reduce(\n            (currentMaxIndex, energy, index) => {\n                const currentMaxEnergy = freqBins[currentMaxIndex] || 0;\n                if (energy > 0 && energy > currentMaxEnergy) {\n                    return index;\n                }\n                return currentMaxIndex;\n            },\n            -1\n        );\n\n        // We heard silence\n        if (maxEnergyIndex === -1 && blippin) {\n            blippin = false;\n        }\n\n        // We heard a blip!\n        if (maxEnergyIndex !== -1 && !blippin) {\n            blippin = true;\n\n            if (recordBlipTimes) {\n                blipTimes.push(Date.now() - firstBlipTime);\n            }\n\n            // The last peer, on receiving the first blip,\n            // signals to the initiator that everything's good to go.\n            if (firstBlip && iAmLast) {\n                firstBlip = false;\n                const initiatorId = order[0];\n                const initiator = peers[initiatorId];\n                initiator.send(JSON.stringify({\n                    type : 'SEND_RECORD_SIGNAL'\n                }));\n            }\n\n            // const binLow = Math.floor(maxEnergyIndex * freqResolution);\n            // const binHigh = Math.floor((maxEnergyIndex + 1) * freqResolution);\n            // console.log(`HEARD BLIP @ ${binLow}-${binHigh}Hz (bin ${maxEnergyIndex}, waiting for ${expectedFreqIndex})`);\n\n            const blipBinDistance = Math.abs(blipBin - maxEnergyIndex);\n            const doubleBlipBinDistance = Math.abs(doubleBlipBin - maxEnergyIndex)\n            if (doubleBlipBinDistance < blipBinDistance) {\n                console.log(`HEARD HIGH BLIP NEAR ${doubleBlipFreq}Hz`);\n                if (mode === CASCADE_STANDBY) {\n                    if (countdown === initialState.countdown) {\n                        // On the first high blip of the countdown, start recording\n                        startRecording();\n                        recordBlipTimes = true;\n                        firstBlipTime = Date.now();\n                    }\n                    if (countdown === 1) {\n                        // On the last high blip of the countdown,\n                        // change the UI to show recording\n                        // (even though recording already started)\n                        changeMode(CASCADE_RECORDING, dispatch);\n                        // And reset countdown for next cascade\n                        dispatch({\n                            type      : 'COUNTDOWN_SET',\n                            countdown : initialState.countdown\n                        });\n                    } else {\n                        dispatch({\n                            type      : 'COUNTDOWN_SET',\n                            countdown : countdown - 1\n                        });\n                    }\n                }\n            } else {\n                console.log(`HEARD LOW BLIP NEAR ${blipFreq}Hz`);\n            }\n        }\n    }, timeResolution);\n}\n","import { changeMode } from './cascade';\nimport { handleOrderSet, handlePeerSignal } from './peers';\nimport { getState } from '../reducer';\n\nexport function serverSend(sendAction) {\n    const { server } = getState();\n    server.send(JSON.stringify(sendAction));\n}\n\nexport function makeServer(serverURL, dispatch) {\n    // We set the server connection here because\n    // we need access to dispatch in the event listeners.\n    const server = new WebSocket(serverURL);\n    server.addEventListener('open', () => console.log('opening socket'));\n    // TODO: handle failed connection\n    server.addEventListener('close', () => console.log('closing socket'));\n    server.addEventListener('error', () => console.log('socket error'));\n    server.addEventListener('message', ({ data }) => {\n        const action = JSON.parse(data);\n        console.log('ACTION (from server):', action);\n        // Some actions have side effects and should only happen once.\n        // (a single dispatch can call the reducer multiple times)\n        switch (action.type) {\n            case 'MODE_SET':\n                changeMode(action.mode, dispatch);\n                break;\n            case 'ORDER_SET':\n                handleOrderSet(action, dispatch);\n                break;\n            case 'PEER_SIGNAL':\n                handlePeerSignal(action, dispatch);\n                break;\n            case 'pong':\n                break;\n            default:\n                // Otherwise, messages from the server\n                // are simply actions for the reducer.\n                dispatch(action);\n        }\n    });\n    setInterval(() => {\n        // Keep the connection alive\n        serverSend({ type : 'ping' });\n    }, 30000);\n    dispatch({\n        type : 'SERVER_SET',\n        server\n    });\n}\n","import Peer from 'simple-peer';\nimport {\n    CASCADE_DONE,\n    CASCADE_STANDBY,\n    addCascadedStream,\n    changeMode,\n    cleanStream\n} from './cascade';\nimport { sendRecordSignal } from './recording';\nimport { serverSend } from './server';\nimport { getState } from '../reducer';\n\nexport function handleOrderSet(action, dispatch) {\n    const { order : newOrder } = action;\n    const { myId, order : oldOrder, peers, streams } = getState();\n    dispatch(action);\n\n    // If receiving order for the first time,\n    // initialize a new peer for everyone else waiting\n    if (oldOrder.length === 0) {\n        newOrder.forEach((id) => {\n            if (id !== myId && !peers[id]) {\n                makeNewPeer(true, id, dispatch);\n            }\n        });\n    }\n\n    // If peers have been removed, clean up the connections\n    const removedPeers = oldOrder.reduce((accumulator, id) => {\n        if (newOrder.includes(id)) return accumulator;\n        return accumulator.concat(id);\n    }, []);\n    removedPeers.forEach((id) => {\n        cleanStream(streams[id]);\n        peers[id].destroy();\n    });\n}\n\nfunction makeNewPeer(initiator, peerId, dispatch) {\n    const { myId, myStream } = getState();\n    // Clone this because we'll stop the tracks during cascade,\n    // which would stop our view of ourself\n    const sendStream = myStream.clone();\n    const peer = new Peer({\n        initiator,\n        stream : sendStream\n    });\n    // Peer doesn't keep track of the sending streams.\n    // We're doing a bunch of stream cloning\n    // (because you can't send the same stream more than once :shrug:)\n    // so we need to keep track of the streams that were sent.\n    peer._sendStreams = [sendStream];\n\n    peer.on('signal', (signal) => {\n        serverSend({\n            type   : 'PEER_SIGNAL',\n            forId  : peerId,\n            fromId : myId,\n            signal\n        });\n    });\n\n    peer.on('stream', (theirStream) => {\n        const { mode } = getState();\n        if (mode === CASCADE_STANDBY) {\n            addCascadedStream(theirStream, dispatch);\n        } else {\n            dispatch({\n                type   : 'STREAMS_ADD',\n                id     : peerId,\n                stream : theirStream\n            });\n            // After cascading, if this is sent from downstream,\n            // we need to reciprocate and reopen our stream as well\n            // (except for the next peer, which we're already streaming to)\n            if (mode === CASCADE_DONE && peer._sendStreams.length === 0) {\n                addStream(peer, myStream.clone());\n            }\n        }\n    });\n\n    // The peer data channel is currently only used\n    // for propagating mode changes down the cascade\n    peer.on('data', (data) => {\n        const { mode, type } = JSON.parse(data.toString());\n        if (type === 'MODE_SET') {\n            changeMode(mode, dispatch);\n        } else if (type === 'SEND_RECORD_SIGNAL') {\n            sendRecordSignal();\n        } else {\n            console.error(`Unknown action \"${type}\" sent thru peer`);\n        }\n    });\n\n    dispatch({\n        type : 'PEERS_ADD',\n        id   : peerId,\n        peer\n    });\n    return peer;\n}\n\nexport function handlePeerSignal(action, dispatch) {\n    const { peers } = getState();\n    const { fromId, signal } = action;\n    const existingPeer = peers[fromId];\n    const peer = existingPeer || makeNewPeer(false, fromId, dispatch);\n    peer.signal(signal);\n}\n\nexport function addStream(peer, stream) {\n    peer.addStream(stream);\n    peer._sendStreams.push(stream);\n}\n\nexport function popStream(peer) {\n    const stream = peer._sendStreams.pop();\n    cleanStream(stream);\n    peer.removeStream(stream);\n    return stream;\n}\n","import { addStream, popStream } from './peers';\nimport {\n    connectBlipListener,\n    sendBlips,\n    startRecording,\n    stopRecording\n} from './recording';\nimport { serverSend } from './server';\nimport { getState } from '../reducer';\n\n// User is connecting audio/video, hasn't connected to server\nexport const SETUP = 0;\n// Connected to server, waiting for initiator to press GO\nexport const READY = 1;\n// Cascade has started but recording hasn't started yet.\n// For initiator, there's a short countdown.\n// For everyone else, it's just waiting on the stream to arrive.\nexport const CASCADE_STANDBY = 2;\n// Cascade in progress!\n// This will end for the initiator when they press the DONE button\n// and for everyone else when the stream ends.\nexport const CASCADE_RECORDING = 3;\n// After the cascade is finished, restarting connections needs to be handled differently.\n// Upstream peers should only send their video downstream after the downstream peers have finished.\nexport const CASCADE_DONE = 4;\n\n\nexport function getNextPeer() {\n    const { myId, order, peers } = getState();\n    const nextIndex = order.indexOf(myId) + 1;\n    const nextId = order[nextIndex];\n    return peers[nextId];\n}\n\nexport function cleanStream(stream) {\n    stream.getTracks().forEach((track) => track.stop());\n}\n\nfunction cascadeModeSet(mode) {\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        nextPeer.send(JSON.stringify({\n            type : 'MODE_SET',\n            mode\n        }));\n    }\n}\n\nexport function changeMode(newMode, dispatch) {\n    dispatch({\n        type : 'MODE_SET',\n        mode : newMode\n    });\n\n    switch (newMode) {\n        case CASCADE_STANDBY:\n            setupCascade();\n            break;\n        case CASCADE_DONE:\n            stopRecording();\n            cascadeModeSet(CASCADE_DONE);\n            resetStreams();\n            break;\n        default:\n    }\n}\n\nexport function startCascade(dispatch) {\n    const { myId } = getState();\n    // dispatch MODE_SET and broadcast via server\n    // (server will set lock on new participants)\n    const mode = CASCADE_STANDBY;\n    const action = {\n        type   : 'MODE_SET',\n        fromId : myId,\n        mode\n    };\n    serverSend(action);\n    changeMode(mode, dispatch);\n    sendBlips(dispatch);\n}\n\nexport function getDownstreamIds() {\n    const { myId, order } = getState();\n    const myIndex = order.indexOf(myId);\n    return order.slice(myIndex + 1);\n}\n\nexport function getUpstreamIds() {\n    const { myId, order } = getState();\n    const myIndex = order.indexOf(myId);\n    return order.slice(0, myIndex);\n}\n\nfunction setupCascade() {\n    const { peers } = getState();\n\n    // Disconnect stream from all upstream peers\n    // and all downstream peers except the one right after\n    const disconnectIds = [\n        ...getUpstreamIds(),\n        ...getDownstreamIds().slice(1)\n    ];\n    disconnectIds.forEach((id) => {\n        const peer = peers[id];\n        // There should only be one stream per peer in this stage\n        popStream(peer);\n    });\n}\n\nlet hasBlips = false;\nexport function addCascadedStream(stream, dispatch) {\n    console.log(\"RECEIVING CASCADED STREAM\");\n    const { myId, order, streams } = getState();\n    const nextPeer = getNextPeer();\n\n    // The first cascaded stream is a blip track for syncing later\n    if (!hasBlips) {\n        hasBlips = true;\n        connectBlipListener(stream, dispatch);\n        // After receiving the blip stream,\n        // cascade it and the stream from the previous peer\n        // to the next peer.\n        const myIndex = order.indexOf(myId);\n        const prevId = order[myIndex - 1];\n        const prevStream = streams[prevId];\n        if (nextPeer) {\n            addStream(nextPeer, stream);\n            addStream(nextPeer, prevStream.clone());\n        }\n    } else {\n        // Find the next upstream id from here that doesn't have a stream set\n        const upstreamIds = getUpstreamIds().slice(0, -1).reverse();\n        const id = upstreamIds.find((upstreamId) => !streams[upstreamId]);\n        dispatch({\n            type : 'STREAMS_ADD',\n            id,\n            stream,\n        });\n\n        if (nextPeer) {\n            addStream(nextPeer, stream);\n        }\n    }\n}\n\nexport function stopCascade(dispatch) {\n    // changeMode(CASCADE_DONE, dispatch);\n    const { order, peers } = getState();\n    const initiatorId = order[0];\n    peers[initiatorId].send(JSON.stringify({\n        type : 'MODE_SET',\n        mode : CASCADE_DONE\n    }));\n}\n\nfunction resetStreams() {\n    const { myStream, peers } = getState();\n\n    hasBlips = false;\n\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        // Remove the cascaded streams\n        while (nextPeer._sendStreams.length > 1) {\n            popStream(nextPeer);\n        }\n    }\n\n    // Send live video back to everyone upstream\n    // They will reciprocate if they're not already sending video\n    const beforeIds = getUpstreamIds();\n    beforeIds.forEach((id) => {\n        const peer = peers[id];\n        addStream(peer, myStream.clone());\n    });\n}\n","import { CASCADE_DONE, CASCADE_STANDBY, READY, SETUP } from './actions/cascade';\n\nexport const initialState = {\n    // This needs to be stored here so all video elements output sound to the same place.\n    audioOutput   : null,\n    countdown     : 4,\n    // Blob URLs of the recorded myStream (not combined with other peers)\n    files         : [],\n    // The initiator is whoever is in the first spot.\n    // They have all the power. They get to rearrange the order of the cascade.\n    // And they press the big GO button.\n    iAmInitiator  : false,\n    mode          : SETUP,\n    // UUID generated by the server\n    myId          : null,\n    // MediaStream object containing audio/video\n    myStream      : null,\n    // The order of the participants - how the audios cascades\n    order         : [],\n    // Direct connections to other participants via WebRTC that provide the streams\n    // Keys are the server-generated IDs\n    peers         : {},\n    // WebSocket server connection to send the initial WebRTC signals (and a biiiit more after)\n    server        : null,\n    // MediaStream objects for remote peers\n    // Keys are the server-generated IDs\n    streams       : {}\n};\n\nfunction reducer(state, action) {\n    console.log('ACTION', action);\n    const { files, mode, myId, myStream, order, peers, streams } = state;\n    switch (action.type) {\n        case 'AUDIO_OUTPUT_SET':\n            return {\n                ...state,\n                audioOutput : action.deviceId\n            };\n        case 'COUNTDOWN_SET':\n            return {\n                ...state,\n                countdown : action.countdown\n            };\n        case 'FILES_ADD':\n            return {\n                ...state,\n                files : [\n                    ...files,\n                    [action.fileName, action.blobURL]\n                ]\n            };\n        case 'MODE_SET': {\n            const { mode : newMode } = action;\n            // When starting or ending the cascade, remove all streams except\n            // the prev one (they will be stopped shortly)\n            const myIndex = order.indexOf(myId);\n            const prevId = order[myIndex - 1];\n            const justPrevStream = prevId ?\n                { [prevId] : streams[prevId] } :\n                {};\n            const newStreams = newMode === CASCADE_STANDBY || newMode === CASCADE_DONE ?\n                justPrevStream :\n                streams;\n            return {\n                ...state,\n                mode    : newMode,\n                streams : newStreams\n            };\n        }\n        case 'MY_ID_SET':\n            return {\n                ...state,\n                myId : action.id\n            };\n        case 'MY_STREAM_SET': {\n            // Move from setup mode when myStream is first set\n            const newMode = myStream ? mode : READY;\n            return {\n                ...state,\n                mode     : newMode,\n                myStream : action.stream,\n            };\n        }\n        case 'ORDER_SET': {\n            const { order : newOrder } = action;\n            const myOrderIndex = newOrder.findIndex((otherId) => myId === otherId);\n            const iAmInitiator = myOrderIndex === 0;\n            // If an id has been taken away from the order, remove the peers and streams\n            const [newPeers, newStreams] = newOrder.reduce((accumulator, id) => {\n                if (id === myId) return accumulator;\n                return [\n                    {\n                        ...accumulator[0],\n                        [id] : peers[id]\n                    },\n                    {\n                        ...accumulator[1],\n                        [id] : streams[id]\n                    }\n                ]\n            }, [{}, {}]);\n            return {\n                ...state,\n                iAmInitiator,\n                order   : newOrder,\n                peers   : newPeers,\n                streams : newStreams\n            };\n        }\n        case 'PEERS_ADD':\n            return {\n                ...state,\n                peers : {\n                    ...peers,\n                    [action.id] : action.peer\n                }\n            };\n        case 'SERVER_SET':\n            return {\n                ...state,\n                server : action.server\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams : {\n                    ...streams,\n                    [action.id] : action.stream\n                }\n            };\n        default: {\n            console.error('Unknown action:', action);\n            return state;\n        }\n    }\n};\n\nlet evilBoogiemanGlobalState = {};\nexport function getState() {\n    return evilBoogiemanGlobalState;\n}\n\nexport default function reduceAndSave(state, action) {\n    const newState = reducer(state, action);\n    evilBoogiemanGlobalState = newState;\n    return newState;\n}\n","import React, { createContext, useReducer } from 'react';\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\n\nconst FileList = () => {\n    const [state] = useContext(Context);\n    const { files } = state;\n    return (\n        <aside>\n            { files.map(([fileName, blobURL], index) =>\n                <a\n                    key={blobURL}\n                    download={fileName}\n                    href={blobURL}\n                >\n                    Download your video for cascade {index + 1}\n                </a>) }\n        </aside>\n    );\n};\n\nexport default FileList;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\nimport {\n    CASCADE_DONE,\n    CASCADE_RECORDING,\n    CASCADE_STANDBY,\n    READY,\n    startCascade,\n    stopCascade\n} from '../state/actions/cascade';\n\nconst Navigation = () => {\n    const [state, dispatch] = useContext(Context);\n    const { iAmInitiator, mode, myId, order } = state;\n    const lastId = order[order.length - 1];\n    const iAmLast = myId === lastId;\n    return (\n        <nav>\n            { [READY, CASCADE_DONE].includes(mode) && iAmInitiator && order.length > 1 &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => startCascade(dispatch)}\n                >\n                    GO\n                </button> }\n            { mode === CASCADE_RECORDING && iAmLast &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => stopCascade(dispatch)}\n                >\n                    STOP\n                </button> }\n        </nav>\n    );\n};\n\nexport default Navigation;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\nimport { addStream, popStream } from '../../state/actions/peers';\nimport { makeRecorder } from '../../state/actions/recording';\n\nconst AudioVideoSetup = ({ style }) => {\n    const [state, dispatch] = useContext(Context);\n    const { audioOutput, myStream, peers } = state;\n    const [devices, setDevices] = useState([]);\n    const [showSetup, setShowSetup] = useState(false);\n    const [audioInput, setAudioInput] = useState(null);\n    const [videoInput, setVideoInput] = useState(null);\n    const setAudioOutput = (deviceId) => {\n        dispatch({\n            type : 'AUDIO_OUTPUT_SET',\n            deviceId\n        });\n    }\n\n    useEffect(() => {\n        // On Safari, enumerateDevices only works after getUserMedia is called.\n        // So wait for that to happen before populating the dropdowns.\n        // (Also, missing things even after it's called...)\n        if (myStream && showSetup) {\n            const findDevices = async () => {\n                const deviceList = await navigator.mediaDevices.enumerateDevices();\n                setDevices(deviceList);\n            };\n            findDevices();\n        }\n    }, [myStream, showSetup]);\n\n    useEffect(() => {\n        // Called on the first render\n        // (and any time audioInput or videoInput change)\n        const setStream = async () => {\n            const stream = await navigator.mediaDevices.getUserMedia({\n                audio : {\n                    deviceId         : audioInput && { exact : audioInput },\n                    // These cause latency\n                    autoGainControl  : { exact : false },\n                    echoCancellation : false,\n                    noiseSuppression : { exact : false },\n                },\n                video : {\n                    deviceId : videoInput && { exact : videoInput }\n                }\n            });\n\n            // Record the unprocessed input\n            makeRecorder(stream, dispatch);\n\n            if (myStream) {\n                Object.values(peers).forEach((peer) => {\n                    popStream(peer);\n                    addStream(peer, stream);\n                });\n            }\n\n            dispatch({\n                type   : 'MY_STREAM_SET',\n                stream\n            });\n        };\n        setStream();\n    }, [audioInput, videoInput]);\n\n    const kinds = ['audioinput', 'audiooutput', 'videoinput'];\n    const kindLabels = ['Audio Input', 'Audio Output', 'Video Input'];\n    const selectedDevices = [\n        [audioInput, setAudioInput],\n        [audioOutput, setAudioOutput],\n        [videoInput, setVideoInput]\n    ];\n    // Sort the available devices into the three buckets\n    const devicesSorted = devices.reduce((accumulator, device) => {\n        const { deviceId, kind } = device;\n        const index = kinds.indexOf(kind);\n        return [\n            ...accumulator.slice(0, index),\n            {\n                ...accumulator[index],\n                [deviceId] : device,\n            },\n            ...accumulator.slice(index + 1)\n        ]\n    }, [{}, {}, {}]);\n\n    return (\n        <section className=\"av-setup\" style={style}>\n            { showSetup ? <>\n                { devicesSorted.map((deviceMap, index) => {\n                    const devicesOfType = Object.values(deviceMap);\n                    if (devicesOfType.length === 0) return null;\n                    const label = kindLabels[index];\n                    const [selectedDeviceId, setSelectedDeviceId] = selectedDevices[index];\n                    return (\n                        <label key={label}>\n                            {label}\n                            <select\n                                onChange={(event) => setSelectedDeviceId(event.target.value)}\n                                value={selectedDeviceId || 'default'}\n                            >\n                                { devicesOfType.map(({ deviceId, label }) => (\n                                    <option key={deviceId} value={deviceId}>{label}</option>\n                                )) }\n                            </select>\n                        </label>\n                    );\n                }) }\n                <button onClick={() => setShowSetup(false)}>x</button>\n            </> :\n            <button onClick={() => setShowSetup(true)}>Audio/Video settings</button> }\n        </section>\n    );\n};\n\nexport default AudioVideoSetup;\n","import React, { useContext } from 'react';\nimport { Context } from '../Store';\n\nconst Countdown = () => {\n    const [state] = useContext(Context);\n    const { countdown } = state;\n    return <span className=\"countdown\">{countdown}</span>\n};\n\nexport default Countdown;\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious(value) {\n    const prevRef = useRef();\n    useEffect(() => {\n        prevRef.current = value;\n    }, [value]);\n    return prevRef.current;\n}\n","import React, { useCallback, useContext } from 'react';\nimport { Context } from '../Store';\nimport usePrevious from '../../state/use-previous';\n\nconst Video = ({ id, isMe, setVideoAspectRatio, stream }) => {\n    const [state] = useContext(Context);\n    const { audioOutput } = state;\n\n    const prevStream = usePrevious(stream);\n    const prevAudioOutput = usePrevious(audioOutput);\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if (stream !== prevStream) {\n                node.addEventListener('loadedmetadata', ({ target }) => {\n                    setVideoAspectRatio(target.videoWidth / target.videoHeight);\n                });\n                if ('srcObject' in node) {\n                    node.srcObject = stream;\n                } else {\n                    node.src = URL.createObjectURL(stream);\n                }\n            }\n\n            if (audioOutput && audioOutput !== prevAudioOutput) {\n                // TODO: check if available, alert user if not\n                // (Firefox needs setting enabled)\n                // (Safari is ?)\n                node.setSinkId(audioOutput);\n            }\n        }\n    }, [audioOutput, stream]);\n\n    return stream ?\n        <video autoPlay ref={videoRef} /> :\n        null;\n};\n\nexport default Video;\n","import React, { useContext, useEffect, useRef, useState } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport Countdown from './Countdown';\nimport Video from './Video';\nimport { Context } from '../Store';\nimport {\n    CASCADE_DONE,\n    CASCADE_RECORDING,\n    CASCADE_STANDBY,\n    READY\n} from '../../state/actions/cascade';\nimport { serverSend } from '../../state/actions/server';\n\nconst VideoSquare = ({\n    col,\n    id,\n    isMe,\n    numColumns,\n    orderNumber,\n    row,\n    stream\n}) => {\n    const [state, dispatch] = useContext(Context);\n    const { iAmInitiator, mode, myId, order } = state;\n\n    const dndRef = useRef(null);\n    const [{ isDragging }, connectDrag] = useDrag({\n        item    : { id, type : 'participant' },\n        canDrag : () => iAmInitiator && [READY, CASCADE_DONE].includes(mode),\n        collect : (monitor) => ({ isDragging : monitor.isDragging() })\n    });\n    const [, connectDrop] = useDrop({\n        accept : 'participant',\n        drop   : (item) => {\n            serverSend({\n                type   : 'ORDER_SET',\n                fromId : myId,\n                order,\n            });\n        },\n        hover  : ({ id : hoveredOverId }) => {\n            if (hoveredOverId !== id) {\n                const myIndex = order.indexOf(id);\n                const theirIndex = order.indexOf(hoveredOverId);\n                const newOrder = [...order];\n                newOrder[myIndex] = hoveredOverId;\n                newOrder[theirIndex] = id;\n                dispatch({\n                    type  : 'ORDER_SET',\n                    order : newOrder\n                });\n            }\n        }\n    });\n    connectDrag(dndRef);\n    connectDrop(dndRef);\n\n    const style = {\n        gridColumn : `${col} / span 1`,\n        gridRow    : `${row} / span 1`,\n        opacity    : isDragging ? 0.5 : 1,\n    };\n\n    // This ridiculousness is to make the order number &\n    // settings button hover over the video\n    const [videoAspectRatio, setVideoAspectRatio] = useState(null);\n    const [left, setLeft] = useState(0);\n    const [top, setTop] = useState(0);\n    useEffect(() => {\n        const element = dndRef.current;\n        if (element && videoAspectRatio) {\n            const videoResizeObserver = new ResizeObserver((entries) => {\n                entries.forEach((entry) => {\n                    const { width, height } = entry.contentRect;\n                    // Try to fill height\n                    let videoHeight = height;\n                    let videoWidth = videoHeight * videoAspectRatio;\n                    // If width overflows, fill width\n                    if (videoWidth > width) {\n                        videoWidth = width;\n                        videoHeight = videoWidth / videoAspectRatio;\n                    }\n                    setLeft((width - videoWidth) / 2);\n                    setTop((height - videoHeight) / 2);\n                });\n            });\n            videoResizeObserver.observe(element);\n            return () => {\n                videoResizeObserver.disconnect();\n            };\n        }\n    }, [videoAspectRatio]);\n    const showOrderNumber = orderNumber > 0 && videoAspectRatio && dndRef.current;\n    const orderNumberStyle = {\n        backgroundColor : (\n            mode === CASCADE_STANDBY && 'yellow'\n        ) || (\n            mode === CASCADE_RECORDING && 'red'\n        ) || 'green',\n        left            : `calc(${left}px + 1%)`,\n        top             : `calc(${top}px + 1%)`\n    };\n    const settingsButtonStyle = {\n        right : orderNumberStyle.left,\n        top   : orderNumberStyle.top\n    };\n\n    return (\n        <div ref={dndRef} className=\"video-draggable\" style={style}>\n            <Video id={id} isMe={isMe} setVideoAspectRatio={setVideoAspectRatio} stream={stream} />\n            { isMe && <AudioVideoSetup style={settingsButtonStyle} /> }\n            { showOrderNumber &&\n                <span className=\"order-number\" style={orderNumberStyle}>{orderNumber}</span> }\n            { mode === CASCADE_STANDBY && isMe &&\n                <Countdown /> }\n        </div>\n    );\n};\n\nexport default VideoSquare;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\n\nconst VideoGrid = () => {\n    const [state] = useContext(Context);\n    const { myId, myStream, order, streams } = state;\n\n    const numParticipants = Object.values(streams).length + 1;\n    // Add a new row when the number of participants exceeds the perfect square\n    // (2-4 partcipants have two columns, 5-9 have three columns, 10-16 have four columns, etc)\n    const cols = Math.ceil(Math.sqrt(numParticipants));\n    const rows = Math.ceil(numParticipants / cols);\n    const colPct = 100 / cols;\n    const rowPct = 100 / rows;\n    const gridStyles = {\n        gridTemplateColumns : `repeat(${cols}, ${colPct}%)`,\n        gridTemplateRows    : `repeat(${cols}, ${rowPct}%)`,\n    };\n\n    const getOrderProps = (id) => {\n        const orderNumber = order.indexOf(id) + 1;\n        const row = Math.ceil(orderNumber / cols);\n        const numBeforeRow = (row - 1) * cols;\n        const col = orderNumber - numBeforeRow;\n        return {\n            col,\n            orderNumber,\n            row\n        };\n    };\n\n    return (\n        <main className=\"video-grid\" style={gridStyles}>\n            <VideoSquare id={myId} isMe stream={myStream} {...getOrderProps(myId)} />\n            { Object.entries(streams).map(([id, stream]) =>\n                <VideoSquare key={id} id={id} stream={stream} {...getOrderProps(id)} />\n            ) }\n        </main>\n    );\n};\n\nexport default VideoGrid;\n","import React from 'react';\n\nconst Welcome = ({ onClick }) => {\n    return <>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video. Before you click the button, put on headphones so there's no feedback!</div>\n        <button onClick={onClick}>\n            Let's go!\n        </button>\n    </>;\n};\n\nexport default Welcome;\n","import React, { useContext, useState } from 'react';\nimport FileList from './FileList';\nimport Navigation from './Navigation';\nimport { Context } from './Store';\nimport VideoGrid from './VideoGrid';\nimport Welcome from './Welcome';\n\nconst GreenRoom = () => {\n    const [state] = useContext(Context);\n    console.log('STATE', state);\n\n    const [showWelcome, setShowWelcome] = useState(true);\n    if (showWelcome) {\n        return <Welcome onClick={() => setShowWelcome(false)} />;\n    }\n\n    return <>\n        <VideoGrid />\n        <Navigation />\n        <FileList />\n    </>;\n};\n\nexport default GreenRoom;\n","import { useContext, useEffect } from 'react';\nimport { Context } from './Store';\nimport usePrevious from '../state/use-previous';\nimport { makeServer } from '../state/actions/server';\n\nconst ServerProvider = ({ children }) => {\n    const [state, dispatch] = useContext(Context);\n    const { myStream } = state;\n    const prevMyStream = usePrevious(myStream);\n    const params = new URLSearchParams(window.location.search);\n    const serverURL = params.get('server');\n    useEffect(() => {\n        // Start the server connection only when myStream is first initiated\n        if (myStream && !prevMyStream && serverURL) {\n            makeServer(serverURL, dispatch);\n        }\n    }, [myStream, prevMyStream, serverURL]);\n\n    if (!serverURL) {\n        return \"You have to have a server. Sorry, that's just the way it is.\";\n    }\n\n    return children;\n};\n\nexport default ServerProvider;\n","import React from 'react';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport GreenRoom from './GreenRoom';\nimport ServerProvider from './ServerProvider';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <ServerProvider>\n                <DndProvider backend={HTML5Backend}>\n                    <GreenRoom />\n                </DndProvider>\n            </ServerProvider>\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}