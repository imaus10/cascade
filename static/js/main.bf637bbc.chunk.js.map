{"version":3,"sources":["state/actions/peers.js","state/actions/cascade.js","state/actions/recording.js","state/actions/server.js","state/reducer.js","components/Store.jsx","components/FileList.jsx","components/Navigation.jsx","components/VideoSquare/AudioVideoSetup.jsx","components/VideoSquare/Countdown.jsx","state/use-previous.js","components/VideoSquare/Video.jsx","components/VideoSquare/index.jsx","components/VideoGrid.jsx","components/Welcome.jsx","components/GreenRoom.jsx","components/ServerProvider.jsx","components/App.js","serviceWorker.js","index.js"],"names":["makeNewPeer","initiator","newId","dispatch","getState","myId","myStream","peer","Peer","stream","clone","on","signal","serverSend","type","forId","fromId","theirStream","mode","CASCADE_STANDBY","streams","id","getUpstreamIds","slice","reverse","find","upstreamId","nextPeer","getNextPeer","addStream","addCascadedStream","streamReceivedTimes","Date","now","CASCADE_DONE","length","data","JSON","parse","toString","console","error","changeMode","sendAction","server","send","stringify","makeServer","serverURL","WebSocket","addEventListener","log","action","newOrder","order","oldOrder","peers","forEach","reduce","accumulator","includes","concat","destroy","getTracks","track","stop","handleOrderSet","handlePeerSignal","setInterval","cascadeRecordingTime","beforeRecordLatency","playLatencies","makeNewRecorder","recorder","MediaRecorder","mimeType","files","blobURL","URL","createObjectURL","fileName","indexOf","a","sendLatencyInfo","prevIndex","prevId","playLatency","READY","state","nextIndex","cascadeModeSet","newMode","myIndex","getDownstreamIds","removeTrack","prevStream","setupCascade","start","removeStream","resetStreams","initialState","audioOutput","iAmInitiator","evilBoogiemanGlobalState","reduceAndSave","newState","deviceId","justPrevStream","newStreams","findIndex","otherId","newPeers","reducer","Context","createContext","Store","children","useReducer","Provider","value","FileList","useContext","map","index","key","download","href","Navigation","className","onClick","startCascade","stopCascade","audioCtx","window","AudioContext","webkitAudioContext","AudioVideoSetup","useState","devices","setDevices","showSetup","setShowSetup","audioInput","setAudioInput","videoInput","setVideoInput","setStream","navigator","mediaDevices","getUserMedia","audio","exact","autoGainControl","echoCancellation","noiseSuppression","video","Object","values","createMediaStreamSource","connect","destination","useEffect","enumerateDevices","deviceList","findDevices","kinds","kindLabels","selectedDevices","devicesSorted","device","kind","deviceMap","devicesOfType","label","selectedDeviceId","setSelectedDeviceId","onChange","event","target","Countdown","number","setNumber","setTimeout","CASCADE_STANDBY_DURATION","usePrevious","prevRef","useRef","current","Video","isMe","prevAudioOutput","videoRef","useCallback","node","srcObject","src","setPlayLatency","setSinkId","autoPlay","muted","ref","VideoSquare","col","orderNumber","numColumns","row","dndRef","useDrag","item","canDrag","collect","monitor","isDragging","connectDrag","useDrop","accept","drop","hover","hoveredOverId","theirIndex","connectDrop","style","gridColumn","gridRow","opacity","orderNumberStyle","backgroundColor","VideoGrid","numParticipants","cols","Math","ceil","sqrt","rows","colPct","rowPct","gridStyles","gridTemplateColumns","gridTemplateRows","getOrderProps","entries","Welcome","GreenRoom","showWelcome","setShowWelcome","ServerProvider","prevMyStream","URLSearchParams","location","search","get","App","DndProvider","backend","HTML5Backend","Boolean","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.bf637bbc.chunk.js","sourcesContent":["import Peer from 'simple-peer';\nimport {\n    CASCADE_DONE,\n    CASCADE_STANDBY,\n    addCascadedStream,\n    changeMode\n } from './cascade';\nimport { setStreamReceivedTime } from './recording';\nimport { serverSend } from './server';\nimport { getState } from '../reducer';\n\nexport function handleOrderSet(action, dispatch) {\n    const { order : newOrder } = action;\n    const { myId, order : oldOrder, peers, streams } = getState();\n    dispatch(action);\n\n    // If receiving order for the first time,\n    // initialize a new peer for everyone else waiting\n    if (oldOrder.length === 0) {\n        newOrder.forEach((id) => {\n            if (id !== myId && !peers[id]) {\n                makeNewPeer(true, id, dispatch);\n            }\n        });\n    }\n\n    // If peers have been removed, clean up the connections\n    const removedPeers = oldOrder.reduce((accumulator, id) => {\n        if (newOrder.includes(id)) return accumulator;\n        return accumulator.concat(id);\n    }, []);\n    removedPeers.forEach((id) => {\n        peers[id].destroy();\n        streams[id].getTracks().forEach((track) => track.stop());\n    });\n}\n\nfunction makeNewPeer(initiator, newId, dispatch) {\n    const { myId, myStream } = getState();\n    const peer = new Peer({\n        initiator,\n        stream : myStream.clone()\n    });\n\n    peer.on('signal', (signal) => {\n        serverSend({\n            type   : 'PEER_SIGNAL',\n            forId  : newId,\n            fromId : myId,\n            signal\n        });\n    });\n\n    peer.on('stream', (theirStream) => {\n        const { mode } = getState();\n        if (mode === CASCADE_STANDBY) {\n            addCascadedStream(theirStream, dispatch);\n        } else {\n            dispatch({\n                type   : 'STREAMS_ADD',\n                id     : newId,\n                stream : theirStream\n            });\n            // Mark when the stream is first received to measure the play latency\n            // (the time it takes from receiving the stream to viewing the first frame)\n            setStreamReceivedTime(newId);\n            // After cascading, if this is sent from downstream,\n            // we need to reciprocate and reopen our stream as well\n            if (mode === CASCADE_DONE && peer.streams.length === 0) {\n                peer.addStream(myStream.clone());\n            }\n        }\n    });\n\n    // The peer data channel is currently only used\n    // for propagating mode changes down the cascade\n    peer.on('data', (data) => {\n        const { mode, type } = JSON.parse(data.toString());\n        if (type === 'MODE_SET') {\n            changeMode(mode, dispatch);\n            return;\n        }\n        console.error(`Unknown action \"${type}\" sent thru peer`);\n    });\n\n    dispatch({\n        type : 'PEERS_ADD',\n        id   : newId,\n        peer\n    });\n    return peer;\n}\n\nexport function handlePeerSignal(action, dispatch) {\n    const { peers } = getState();\n    const { fromId, signal } = action;\n    const existingPeer = peers[fromId];\n    const peer = existingPeer || makeNewPeer(false, fromId, dispatch);\n    peer.signal(signal);\n}\n","import { setCascadeRecordingTime } from './recording';\nimport { serverSend } from './server';\nimport { getState } from '../reducer';\n\n// User is connecting audio/video, hasn't connected to server\nexport const SETUP = 0;\n// Connected to server, waiting for initiator to press GO\nexport const READY = 1;\n// Cascade has started but recording hasn't started yet.\n// For initiator, there's a short countdown.\n// For everyone else, it's just waiting on the stream to arrive.\nexport const CASCADE_STANDBY = 2;\n// Cascade in progress!\n// This will end for the initiator when they press the DONE button\n// and for everyone else when the stream ends.\nexport const CASCADE_RECORDING = 3;\n// After the cascade is finished, restarting connections needs to be handled differently.\n// Upstream peers should only send their video downstream after the downstream peers have finished.\nexport const CASCADE_DONE = 4;\nexport const CASCADE_STANDBY_DURATION = 6000; // milliseconds\n\nfunction getNextPeer(state) {\n    const { myId, order, peers } = getState();\n    const nextIndex = order.indexOf(myId) + 1;\n    const nextId = order[nextIndex];\n    return peers[nextId];\n}\n\nfunction cascadeModeSet(mode) {\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        nextPeer.send(JSON.stringify({\n            type : 'MODE_SET',\n            mode\n        }));\n    }\n}\n\nexport function changeMode(newMode, dispatch) {\n    dispatch({\n        type : 'MODE_SET',\n        mode : newMode\n    });\n\n    const { recorder } = getState();\n\n    switch (newMode) {\n        case CASCADE_STANDBY:\n            setupCascade();\n            break;\n        case CASCADE_RECORDING:\n            setCascadeRecordingTime();\n            recorder.start();\n            cascadeModeSet(CASCADE_RECORDING);\n            break;\n        case CASCADE_DONE:\n            recorder.stop();\n            cascadeModeSet(CASCADE_DONE);\n            resetStreams();\n            break;\n        default:\n    }\n}\n\nexport function startCascade(dispatch) {\n    const { myId } = getState();\n    // dispatch MODE_SET and broadcast via server\n    // (server will set lock on new participants)\n    const mode = CASCADE_STANDBY;\n    const action = {\n        type   : 'MODE_SET',\n        fromId : myId,\n        mode\n    };\n    serverSend(action);\n    changeMode(mode, dispatch);\n}\n\nexport function getDownstreamIds() {\n    const { myId, order } = getState();\n    const myIndex = order.indexOf(myId);\n    return order.slice(myIndex + 1);\n}\n\nexport function getUpstreamIds() {\n    const { myId, order } = getState();\n    const myIndex = order.indexOf(myId);\n    return order.slice(0, myIndex);\n}\n\nfunction setupCascade() {\n    const { myId, order, peers, streams } = getState();\n\n    // Disconnect stream from all upstream peers\n    // and all downstream peers except the one right after\n    const disconnectIds = [\n        ...getUpstreamIds(),\n        ...getDownstreamIds().slice(1)\n    ];\n    disconnectIds.forEach((id) => {\n        const peer = peers[id];\n        const stream = peer.streams[0];\n        stream.getTracks().forEach((track) => {\n            track.stop();\n            peer.removeTrack(track, stream);\n        });\n    });\n\n    // To start, send the stream from the previous peer\n    // to the next peer in the cascade.\n    // The rest of the streams will come with the peer stream event,\n    // which calls addCascadedStream()\n    const nextPeer = getNextPeer();\n    const myIndex = order.indexOf(myId);\n    const prevId = order[myIndex - 1];\n    if (prevId && nextPeer) {\n        const prevStream = streams[prevId].clone();\n        nextPeer.addStream(prevStream);\n    }\n}\n\nexport function addCascadedStream(stream, dispatch) {\n    const { streams } = getState();\n\n    // Find the next upstream id from here that doesn't have a stream set\n    const upstreamIds = getUpstreamIds().slice(0, -1).reverse();\n    const id = upstreamIds.find((upstreamId) => !streams[upstreamId]);\n    dispatch({\n        type : 'STREAMS_ADD',\n        id,\n        stream,\n    });\n\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        nextPeer.addStream(stream);\n    }\n}\n\nexport function stopCascade(dispatch) {\n    changeMode(CASCADE_DONE, dispatch);\n}\n\nfunction resetStreams() {\n    const { myStream, peers } = getState();\n\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        // Remove the cascaded streams\n        // The streams stay in the order they're added\n        nextPeer.streams.slice(1).forEach((stream) => {\n            stream.getTracks().forEach((track) => track.stop());\n            nextPeer.removeStream(stream);\n        });\n    }\n\n    // Send live video back to everyone upstream\n    // They will reciprocate if they're not already sending video\n    const beforeIds = getUpstreamIds();\n    beforeIds.forEach((id) => {\n        const peer = peers[id];\n        peer.addStream(myStream.clone());\n    });\n}\n","import { serverSend } from './server';\nimport { getState } from '../reducer';\n\nconst streamReceivedTimes = {};\nexport function setStreamReceivedTime(id) {\n    streamReceivedTimes[id] = Date.now();\n}\nconst playLatencies = {};\nexport function setPlayLatency(id) {\n    playLatencies[id] = Date.now() - streamReceivedTimes[id];\n}\nlet cascadeRecordingTime;\nexport function setCascadeRecordingTime() {\n    cascadeRecordingTime = Date.now();\n}\nlet beforeRecordLatency;\nfunction setBeforeRecordLatency() {\n    beforeRecordLatency = Date.now() - cascadeRecordingTime;\n}\n\nexport function makeNewRecorder(stream, dispatch) {\n    // TODO: use specific codecs. check browser compatibility.\n    const recorder = new MediaRecorder(stream, { mimeType : 'video/webm' });\n    recorder.addEventListener('dataavailable', ({ data }) => {\n        const { files, myId, order } = getState();\n        dispatch({\n            type     : 'FILES_ADD',\n            blobURL  : URL.createObjectURL(data),\n            fileName : `cascade${files.length + 1}_video${order.indexOf(myId) + 1}.webm`\n        });\n    });\n    recorder.addEventListener('start', async () => {\n        setBeforeRecordLatency();\n        sendLatencyInfo();\n    });\n    return recorder;\n}\n\nexport function sendLatencyInfo() {\n    const { myId, order } = getState();\n    const prevIndex = order.indexOf(myId) - 1;\n    const prevId = order[prevIndex];\n    const playLatency = playLatencies[prevId];\n    let latencyInfo = {\n        type   : 'latency_info',\n        fromId : myId,\n        beforeRecordLatency,\n        playLatency,\n    };\n    serverSend(latencyInfo);\n}\n","import { changeMode } from './cascade';\nimport { handleOrderSet, handlePeerSignal } from './peers';\nimport { getState } from '../reducer';\n\nexport function serverSend(sendAction) {\n    const { server } = getState();\n    server.send(JSON.stringify(sendAction));\n}\n\nexport function makeServer(serverURL, dispatch) {\n    // We set the server connection here because\n    // we need access to dispatch in the event listeners.\n    const server = new WebSocket(serverURL);\n    server.addEventListener('open', () => console.log('opening socket'));\n    // TODO: handle failed connection\n    server.addEventListener('close', () => console.log('closing socket'));\n    server.addEventListener('error', () => console.log('socket error'));\n    server.addEventListener('message', ({ data }) => {\n        const action = JSON.parse(data);\n        console.log('ACTION (from server):', action);\n        // Some actions have side effects and should only happen once.\n        // (a single dispatch can call the reducer multiple times)\n        switch (action.type) {\n            case 'MODE_SET':\n                changeMode(action.mode, dispatch);\n                break;\n            case 'ORDER_SET':\n                handleOrderSet(action, dispatch);\n                break;\n            case 'PEER_SIGNAL':\n                handlePeerSignal(action, dispatch);\n                break;\n            case 'pong':\n                break;\n            default:\n                // Otherwise, messages from the server\n                // are simply actions for the reducer.\n                dispatch(action);\n        }\n    });\n    setInterval(() => {\n        // Keep the connection alive\n        serverSend({ type : 'ping' });\n    }, 30000);\n    dispatch({\n        type : 'SERVER_SET',\n        server\n    });\n}\n","import { CASCADE_DONE, CASCADE_STANDBY, READY, SETUP } from './actions/cascade';\nimport { makeNewRecorder } from './actions/recording';\n\nexport const initialState = {\n    // This needs to be stored here so all video elements output sound to the same place.\n    audioOutput   : null,\n    // Blob URLs of the recorded myStream (not combined with other peers)\n    files         : [],\n    // The initiator is whoever is in the first spot.\n    // They have all the power. They get to rearrange the order of the cascade.\n    // And they press the big GO button.\n    iAmInitiator  : false,\n    mode          : SETUP,\n    // UUID generated by the server\n    myId          : null,\n    // MediaStream object containing audio/video\n    myStream      : null,\n    // The order of the participants - how the audios cascades\n    order         : [],\n    // Direct connections to other participants via WebRTC that provide the streams\n    // Keys are the server-generated IDs\n    peers         : {},\n    // Records myStream during cascade\n    recorder      : null,\n    // WebSocket server connection to send the initial WebRTC signals (and a biiiit more after)\n    server        : null,\n    // MediaStream objects for remote peers\n    // Keys are the server-generated IDs\n    streams       : {}\n};\n\nfunction reducer(state, action) {\n    console.log('ACTION', action);\n    const { files, mode, myId, myStream, order, peers, streams } = state;\n    switch (action.type) {\n        case 'AUDIO_OUTPUT_SET':\n            return {\n                ...state,\n                audioOutput : action.deviceId\n            };\n        case 'FILES_ADD':\n            return {\n                ...state,\n                files : [\n                    ...files,\n                    [action.fileName, action.blobURL]\n                ]\n            };\n        case 'MODE_SET': {\n            const { mode : newMode } = action;\n            // When starting or ending the cascade, remove all streams except\n            // the prev one (they will be stopped shortly)\n            const myIndex = order.indexOf(myId);\n            const prevId = order[myIndex - 1];\n            const justPrevStream = prevId ?\n                { [prevId] : streams[prevId] } :\n                {};\n            const newStreams = newMode === CASCADE_STANDBY || newMode === CASCADE_DONE ?\n                justPrevStream :\n                streams;\n            return {\n                ...state,\n                mode    : newMode,\n                streams : newStreams\n            };\n        }\n        case 'MY_ID_SET':\n            return {\n                ...state,\n                myId : action.id\n            };\n        case 'MY_STREAM_SET': {\n            // Move from setup mode when myStream is first set\n            const newMode = myStream ? mode : READY;\n            return {\n                ...state,\n                mode     : newMode,\n                myStream : action.stream,\n                recorder : makeNewRecorder(action.stream, action.dispatch)\n            };\n        }\n        case 'ORDER_SET': {\n            const { order : newOrder } = action;\n            const myOrderIndex = newOrder.findIndex((otherId) => myId === otherId);\n            const iAmInitiator = myOrderIndex === 0;\n            // If an id has been taken away from the order, remove the peers and streams\n            const [newPeers, newStreams] = newOrder.reduce((accumulator, id) => {\n                if (id === myId) return accumulator;\n                return [\n                    {\n                        ...accumulator[0],\n                        [id] : peers[id]\n                    },\n                    {\n                        ...accumulator[1],\n                        [id] : streams[id]\n                    }\n                ]\n            }, [{}, {}]);\n            return {\n                ...state,\n                iAmInitiator,\n                order   : newOrder,\n                peers   : newPeers,\n                streams : newStreams\n            };\n        }\n        case 'PEERS_ADD':\n            return {\n                ...state,\n                peers : {\n                    ...peers,\n                    [action.id] : action.peer\n                }\n            };\n        case 'SERVER_SET':\n            return {\n                ...state,\n                server : action.server\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams : {\n                    ...streams,\n                    [action.id] : action.stream\n                }\n            };\n        case 'STREAMS_REMOVE': {\n            const newStreams = { ...streams };\n            delete newStreams[action.id];\n            return {\n                ...state,\n                streams : newStreams\n            };\n        }\n        default: {\n            console.error('Unknown action:', action);\n            return state;\n        }\n    }\n};\n\nlet evilBoogiemanGlobalState = {};\nexport function getState() {\n    return evilBoogiemanGlobalState;\n}\n\nexport default function reduceAndSave(state, action) {\n    const newState = reducer(state, action);\n    evilBoogiemanGlobalState = newState;\n    return newState;\n}\n","import React, { createContext, useReducer } from 'react';\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\n\nconst FileList = () => {\n    const [state] = useContext(Context);\n    const { files } = state;\n    return (\n        <aside>\n            { files.map(([fileName, blobURL], index) =>\n                <a\n                    key={blobURL}\n                    download={fileName}\n                    href={blobURL}\n                >\n                    Download your video for cascade {index + 1}\n                </a>) }\n        </aside>\n    );\n};\n\nexport default FileList;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\nimport {\n    CASCADE_DONE,\n    CASCADE_RECORDING,\n    READY,\n    startCascade,\n    stopCascade\n} from '../state/actions/cascade';\n\nconst Navigation = () => {\n    const [state, dispatch] = useContext(Context);\n    const { iAmInitiator, mode, order } = state;\n    return (\n        <nav>\n            { [READY, CASCADE_DONE].includes(mode) && iAmInitiator && order.length > 1 &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => startCascade(dispatch)}\n                >\n                    GO\n                </button> }\n            { mode === CASCADE_RECORDING && iAmInitiator &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => stopCascade(dispatch)}\n                >\n                    STOP\n                </button> }\n        </nav>\n    );\n};\n\nexport default Navigation;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\n\n// Safari, what the hell.\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nconst audioCtx = new AudioContext();\n\nconst AudioVideoSetup = () => {\n    const [state, dispatch] = useContext(Context);\n    const { audioOutput, myStream, peers } = state;\n    const [devices, setDevices] = useState([]);\n    const [showSetup, setShowSetup] = useState(false);\n    const [audioInput, setAudioInput] = useState(null);\n    const [videoInput, setVideoInput] = useState(null);\n    const setAudioOutput = (deviceId) => {\n        dispatch({\n            type : 'AUDIO_OUTPUT_SET',\n            deviceId\n        });\n    }\n\n    const setStream = async () => {\n        const stream = await navigator.mediaDevices.getUserMedia({\n            audio : {\n                deviceId         : audioInput && {\n                    exact : audioInput\n                },\n                // These cause latency\n                autoGainControl  : { exact : false },\n                echoCancellation : false,\n                noiseSuppression : { exact : false },\n            },\n            video : {\n                deviceId : videoInput && {\n                    exact : videoInput\n                }\n            }\n        });\n        if (myStream) {\n            myStream.getTracks().forEach((track) => track.stop());\n            Object.values(peers).forEach((peer) => {\n                peer.removeStream(myStream)\n                peer.addStream(stream);\n            });\n        }\n        // Strangely, there is a delay when hearing the audio via the video element.\n        // But the delay is noticeably shorter when using the Web Audio API...\n        // (But only in Chrome?)\n        const source = audioCtx.createMediaStreamSource(stream);\n        // TODO: set output properly. See:\n        // https://stackoverflow.com/questions/41863094/how-to-select-destination-output-device-using-web-audio-api\n        source.connect(audioCtx.destination);\n        dispatch({\n            type : 'MY_STREAM_SET',\n            // Need to dispatch in the recorder ondataavailable event listener\n            dispatch,\n            stream\n        });\n    };\n\n    useEffect(() => {\n        // On Safari, enumerateDevices only works after getUserMedia is called.\n        // So wait for that to happen before populating the dropdowns.\n        // (Also, missing things even after it's called...)\n        if (myStream && showSetup) {\n            const findDevices = async () => {\n                const deviceList = await navigator.mediaDevices.enumerateDevices();\n                setDevices(deviceList);\n            };\n            findDevices();\n        }\n    }, [myStream, showSetup]);\n\n    useEffect(() => {\n        // Called on the first render\n        // (and any time audioInput or videoInput change)\n        setStream();\n    }, [audioInput, videoInput]);\n\n    const kinds = ['audioinput', 'audiooutput', 'videoinput'];\n    const kindLabels = ['Audio Input', 'Audio Output', 'Video Input'];\n    const selectedDevices = [\n        [audioInput, setAudioInput],\n        [audioOutput, setAudioOutput],\n        [videoInput, setVideoInput]\n    ];\n    // Sort the available devices into the three buckets\n    const devicesSorted = devices.reduce((accumulator, device) => {\n        const { deviceId, kind } = device;\n        const index = kinds.indexOf(kind);\n        return [\n            ...accumulator.slice(0, index),\n            {\n                ...accumulator[index],\n                [deviceId] : device,\n            },\n            ...accumulator.slice(index + 1)\n        ]\n    }, [{}, {}, {}]);\n\n    return (\n        <section className=\"av-setup\">\n            { showSetup ? <>\n                { devicesSorted.map((deviceMap, index) => {\n                    const devicesOfType = Object.values(deviceMap);\n                    if (devicesOfType.length === 0) return null;\n                    const label = kindLabels[index];\n                    const [selectedDeviceId, setSelectedDeviceId] = selectedDevices[index];\n                    return (\n                        <label key={label}>\n                            {label}\n                            <select\n                                onChange={(event) => setSelectedDeviceId(event.target.value)}\n                                value={selectedDeviceId || 'default'}\n                            >\n                                { devicesOfType.map(({ deviceId, label }) => (\n                                    <option key={deviceId} value={deviceId}>{label}</option>\n                                )) }\n                            </select>\n                        </label>\n                    );\n                }) }\n                <button onClick={() => setShowSetup(false)}>x</button>\n            </> :\n            <button onClick={() => setShowSetup(true)}>Audio/Video settings</button> }\n        </section>\n    );\n};\n\nexport default AudioVideoSetup;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\nimport {\n    CASCADE_RECORDING,\n    CASCADE_STANDBY_DURATION,\n    changeMode\n} from '../../state/actions/cascade';\n\nconst Countdown = () => {\n    // Counts down to zero from here\n    const countdownStart = 3;\n    const [, dispatch] = useContext(Context);\n    const [number, setNumber] = useState(countdownStart);\n    useEffect(() => {\n        if (number > 0) {\n            setTimeout(() => {\n                setNumber(number - 1);\n            }, CASCADE_STANDBY_DURATION / countdownStart);\n        } else {\n            changeMode(CASCADE_RECORDING, dispatch);\n        }\n    }, [number]);\n    return <span className=\"countdown\">{number}</span>\n};\n\nexport default Countdown;\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious(value) {\n    const prevRef = useRef();\n    useEffect(() => {\n        prevRef.current = value;\n    }, [value]);\n    return prevRef.current;\n}\n","import React, { useCallback, useContext } from 'react';\nimport { Context } from '../Store';\nimport usePrevious from '../../state/use-previous';\nimport { setPlayLatency } from '../../state/actions/recording';\n\nconst Video = ({ id, isMe, stream }) => {\n    const [state] = useContext(Context);\n    const { audioOutput } = state;\n\n    const prevStream = usePrevious(stream);\n    const prevAudioOutput = usePrevious(audioOutput);\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if (stream !== prevStream) {\n                if ('srcObject' in node) {\n                    node.srcObject = stream;\n                } else {\n                    node.src = URL.createObjectURL(stream);\n                }\n                if (!isMe) {\n                    node.addEventListener('play', () => {\n                        setPlayLatency(id);\n                    });\n                }\n            }\n\n            if (audioOutput && audioOutput !== prevAudioOutput) {\n                // TODO: check if available, alert user if not\n                // (Firefox needs setting enabled)\n                // (Safari is ?)\n                node.setSinkId(audioOutput);\n            }\n        }\n    }, [audioOutput, stream]);\n\n    return stream ?\n        <video autoPlay muted={isMe} ref={videoRef} /> :\n        null;\n};\n\nexport default Video;\n","import React, { useContext, useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport Countdown from './Countdown';\nimport Video from './Video';\nimport { Context } from '../Store';\nimport {\n    CASCADE_DONE,\n    CASCADE_RECORDING,\n    CASCADE_STANDBY,\n    READY\n} from '../../state/actions/cascade';\nimport { serverSend } from '../../state/actions/server';\n\nconst VideoSquare = ({\n    col,\n    id,\n    isMe,\n    numColumns,\n    orderNumber,\n    row,\n    stream\n}) => {\n    const [state, dispatch] = useContext(Context);\n    const { iAmInitiator, mode, myId, order } = state;\n\n    const dndRef = useRef(null);\n    const [{ isDragging }, connectDrag] = useDrag({\n        item    : { id, type : 'participant' },\n        canDrag : () => iAmInitiator && [READY, CASCADE_DONE].includes(mode),\n        collect : (monitor) => ({ isDragging : monitor.isDragging() })\n    });\n    const [, connectDrop] = useDrop({\n        accept : 'participant',\n        drop   : (item) => {\n            serverSend({\n                type   : 'ORDER_SET',\n                fromId : myId,\n                order,\n            });\n        },\n        hover  : ({ id : hoveredOverId }) => {\n            if (hoveredOverId !== id) {\n                const myIndex = order.indexOf(id);\n                const theirIndex = order.indexOf(hoveredOverId);\n                const newOrder = [...order];\n                newOrder[myIndex] = hoveredOverId;\n                newOrder[theirIndex] = id;\n                dispatch({\n                    type  : 'ORDER_SET',\n                    order : newOrder\n                });\n            }\n        }\n    });\n    connectDrag(dndRef);\n    connectDrop(dndRef);\n\n    const style = {\n        gridColumn : `${col} / span 1`,\n        gridRow    : `${row} / span 1`,\n        opacity    : isDragging ? 0.5 : 1,\n    };\n    const orderNumberStyle = {\n        backgroundColor : mode === CASCADE_STANDBY ? 'yellow' : (\n            mode === CASCADE_RECORDING ? 'red' : 'green'\n        )\n    };\n\n    return (\n        <div ref={dndRef} className=\"video-draggable\" style={style}>\n            <Video id={id} isMe={isMe} stream={stream} />\n            { isMe && <AudioVideoSetup /> }\n            { orderNumber > 0 &&\n                <span className=\"order-number\" style={orderNumberStyle}>{orderNumber}</span> }\n            { mode === CASCADE_STANDBY && isMe && iAmInitiator &&\n                <Countdown /> }\n        </div>\n    );\n};\n\nexport default VideoSquare;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\n\nconst VideoGrid = () => {\n    const [state] = useContext(Context);\n    console.log('STATE', state);\n    const { myId, myStream, order, streams } = state;\n\n    const numParticipants = Object.values(streams).length + 1;\n    // Add a new row when the number of participants exceeds the perfect square\n    // (2-4 partcipants have two columns, 5-9 have three columns, 10-16 have four columns, etc)\n    const cols = Math.ceil(Math.sqrt(numParticipants));\n    const rows = Math.ceil(numParticipants / cols);\n    const colPct = 100 / cols;\n    const rowPct = 100 / rows;\n    const gridStyles = {\n        gridTemplateColumns : `repeat(${cols}, ${colPct}%)`,\n        gridTemplateRows    : `repeat(${cols}, ${rowPct}%)`,\n    };\n\n    const getOrderProps = (id) => {\n        const orderNumber = order.indexOf(id) + 1;\n        const row = Math.ceil(orderNumber / cols);\n        const numBeforeRow = (row - 1) * cols;\n        const col = orderNumber - numBeforeRow;\n        return {\n            col,\n            orderNumber,\n            row\n        };\n    };\n\n    return (\n        <main className=\"video-grid\" style={gridStyles}>\n            <VideoSquare id={myId} isMe stream={myStream} {...getOrderProps(myId)} />\n            { Object.entries(streams).map(([id, stream]) =>\n                <VideoSquare key={id} id={id} stream={stream} {...getOrderProps(id)} />\n            ) }\n        </main>\n    );\n};\n\nexport default VideoGrid;\n","import React from 'react';\n\nconst Welcome = ({ onClick }) => {\n    return <>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video. Before you click the button, put on headphones so there's no feedback!</div>\n        <button onClick={onClick}>\n            Let's go!\n        </button>\n    </>;\n};\n\nexport default Welcome;\n","import React, { useState } from 'react';\nimport FileList from './FileList';\nimport Navigation from './Navigation';\nimport VideoGrid from './VideoGrid';\nimport Welcome from './Welcome';\n\nconst GreenRoom = () => {\n    const [showWelcome, setShowWelcome] = useState(true);\n\n    if (showWelcome) {\n        return <Welcome onClick={() => setShowWelcome(false)} />;\n    }\n\n    return <>\n        <VideoGrid />\n        <Navigation />\n        <FileList />\n    </>;\n};\n\nexport default GreenRoom;\n","import { useContext, useEffect } from 'react';\nimport { Context } from './Store';\nimport usePrevious from '../state/use-previous';\nimport { makeServer } from '../state/actions/server';\n\nconst ServerProvider = ({ children }) => {\n    const [state, dispatch] = useContext(Context);\n    const { myStream } = state;\n    const prevMyStream = usePrevious(myStream);\n    const params = new URLSearchParams(window.location.search);\n    const serverURL = params.get('server');\n    useEffect(() => {\n        // Start the server connection only when myStream is first initiated\n        if (myStream && !prevMyStream && serverURL) {\n            makeServer(serverURL, dispatch);\n        }\n    }, [myStream, prevMyStream, serverURL]);\n\n    if (!serverURL) {\n        return \"You have to have a server. Sorry, that's just the way it is.\";\n    }\n\n    return children;\n};\n\nexport default ServerProvider;\n","import React from 'react';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport GreenRoom from './GreenRoom';\nimport ServerProvider from './ServerProvider';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <ServerProvider>\n                <DndProvider backend={HTML5Backend}>\n                    <GreenRoom />\n                </DndProvider>\n            </ServerProvider>\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}