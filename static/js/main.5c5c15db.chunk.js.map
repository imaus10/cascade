{"version":3,"sources":["state/events.js","state/reducer.js","components/Store.jsx","components/AddPeer.jsx","components/AddPeers.jsx","components/AudioVideoSetup.jsx","components/VideoSquare.jsx","components/GreenRoom.jsx","components/App.js","serviceWorker.js","index.js"],"names":["makePeer","initiator","stream","Peer","trickle","peerSendJSON","peer","json","send","JSON","stringify","addRelayListeners","state","dispatch","myStream","on","data","action","parse","toString","forId","fromId","console","log","type","id","sendToPeer","myId","theirId","signal","shouldInitiate","handledPeer","sendSignal","sendAction","includes","handlePeerAction","initialState","window","location","hash","peers","streams","reducer","newId","Object","entries","filter","connected","forEach","otherId","otherPeer","relayConnections","Context","createContext","Store","children","useReducer","Provider","value","AddPeer","useContext","useState","isConnected","setIsConnected","myConnectionString","setMyConnectionString","theirConnectionString","setTheirConnectionString","them","setThem","useEffect","connectionInfo","_id","error","myConnectionLabel","theirConnectionLabel","myConnectionField","key","readOnly","theirConnectionField","onChange","event","target","submitButton","connectionFields","push","onSubmit","preventDefault","AddPeers","pendingConnections","setPendingConnections","className","onClick","length","AudioVideoSetup","navigator","mediaDevices","getUserMedia","audio","video","then","VideoSquare","muted","videoRef","useCallback","node","srcObject","src","URL","createObjectURL","autoPlay","ref","GreenRoom","map","App","Boolean","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.5c5c15db.chunk.js","sourcesContent":["import Peer from 'simple-peer';\n\n// Use this function to make Peers so we only have to change\n// the options in one place if/when we enable trickling\nexport function makePeer(initiator, stream) {\n    return new Peer({\n        initiator,\n        stream,\n        // Set to false for now, because with true it sends multiple signals\n        // (will need full signaling server to relay multiple signals)\n        trickle : false\n    });\n}\n\nexport function peerSendJSON(peer, json) {\n    peer.send(JSON.stringify(json));\n}\n\nexport function relayConnections(peers, newId) {\n    console.log(`adding peer ${newId}`);\n    const oldPeers = Object.entries(peers).filter(([id, peer]) => peer.connected && id !== newId);\n    oldPeers.forEach(([otherId, otherPeer]) => {\n        console.log(`sending initiate action to peer ${otherId} for new peer ${newId}`);\n        // This will start the ball rolling.\n        // Then otherPeer will send an offer here,\n        // which we can route to the right peer using forId.\n        // That peer will make an answer and send it here,\n        // which we again route back to otherPeer using fromId.\n        peerSendJSON(otherPeer, {\n            action : 'initiate',\n            forId  : otherId,\n            fromId : newId,\n        });\n    });\n};\n\nexport function addRelayListeners(peer, state, dispatch) {\n    const { initiator, myStream } = state;\n\n    // The room creator just relays the actions\n    const sendToPeer = (data) => {\n        const { action, forId, fromId } = data;\n        console.log(`relaying ${action} for ${forId} from ${fromId}`);\n        dispatch({\n            type : 'PEER_SEND',\n            id   : forId,\n            data\n        });\n    }\n\n    // The invitees to the room have their connections to each other\n    // handled by responding to actions relayed by the room creator,\n    // who has already connected to all participants individually.\n    const handlePeerAction = (data) => {\n        const {\n            action,\n            forId  : myId,\n            fromId : theirId,\n            signal\n        } = data;\n        console.log(`receiving ${action} from ${theirId}`);\n        // These actions generate either an offer or an answer\n        // and should make a new peer\n        if (action === 'initiate' || action === 'offer') {\n            const shouldInitiate = action === 'initiate';\n            const handledPeer = makePeer(shouldInitiate, myStream);\n            handledPeer.on('signal', (sendSignal) => {\n                const sendAction = shouldInitiate ? 'offer' : 'answer';\n                console.log(`sending ${sendAction} for ${theirId}`);\n                if (['offer', 'answer'].includes(sendSignal.type)) {\n                    peerSendJSON(peer, {\n                        action : sendAction,\n                        forId  : theirId,\n                        fromId : myId,\n                        signal : sendSignal,\n                    });\n                } else {\n                    // In practice, seeing { renegotiate: true } signal being\n                    // emitted by the answerer, which we can apparently ignore\n                    // TODO: send all signals? would need to check if peer exists\n                    // before calling makePeer.\n                    // (in reducer, if action is func, call it with state)\n                    console.log('not sending unknown signal type');\n                }\n            });\n            handledPeer.on('stream', (stream) => {\n                dispatch({\n                    type : 'STREAMS_ADD',\n                    id   : theirId,\n                    stream\n                });\n            });\n            if (!shouldInitiate) {\n                // Signal is the offer, generate an answer.\n                handledPeer.signal(signal);\n            }\n            dispatch({\n                type : 'PEERS_ADD',\n                // This is the Peer._id sent from the initiator's machine.\n                id   : theirId,\n                peer : handledPeer\n            });\n        } else if (action === 'answer') {\n            // The offer has received the answer, it just has to signal.\n            console.log('signaling answer');\n            dispatch({\n                type : 'PEER_SIGNAL',\n                id   : theirId,\n                signal\n            });\n        }\n    }\n\n    peer.on('data', (data) => {\n        const action = JSON.parse(data.toString());\n        if (initiator) {\n            sendToPeer(action);\n        } else {\n            handlePeerAction(action);\n        }\n    });\n}\n","import { peerSendJSON, relayConnections } from './events';\n\nexport const initialState = {\n    initiator : window.location.hash === '#init',\n    myStream  : null,\n    peers     : {},\n    streams   : {}\n};\n\n// This reducer is not a pure function and I'm not sorry about it.\n// The PEER (singular) actions don't mutate state but just call Peer functions.\n// That's because when the events are triggered,\n// we need the most recent state provided in this reducer.\nexport default function reducer(state, action) {\n    console.log('ACTION', action);\n    const { peers, streams } = state;\n    switch (action.type) {\n        case 'MY_STREAM_SET':\n            return {\n                ...state,\n                myStream: action.stream\n            };\n        case 'PEER_RELAY': {\n            const { id } = action;\n            relayConnections(peers, id);\n            return state;\n        }\n        case 'PEER_SEND': {\n            const { id, data } = action;\n            peerSendJSON(peers[id], data);\n            return state;\n        }\n        case 'PEER_SIGNAL': {\n            const { id, signal } = action;\n            peers[id].signal(signal);\n            return state;\n        }\n        case 'PEERS_ADD':\n            return {\n                ...state,\n                peers: {\n                    ...peers,\n                    // This ID should match on all machines so the initiator\n                    // can relay signals between invitees automatically.\n                    // It's initially set as Peer._id on the initiator's machine.\n                    [action.id] : action.peer\n                }\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams: {\n                    ...streams,\n                    // This ID matches the peer ID\n                    [action.id] : action.stream,\n                }\n            };\n        default:\n            return state;\n    }\n};\n","import React, { createContext, useReducer } from \"react\";\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from './Store';\nimport { addRelayListeners, makePeer } from '../state/events';\n\nconst AddPeer = () => {\n    const [state, dispatch] = useContext(Context);\n    const { initiator, myStream } = state;\n    const [isConnected, setIsConnected] = useState(false);\n    const [myConnectionString, setMyConnectionString] = useState('');\n    const [theirConnectionString, setTheirConnectionString] = useState('');\n    const [them, setThem] = useState(null);\n\n    useEffect(() => {\n        const peer = makePeer(initiator, myStream);\n        // Provides the connection string to send to remote peer\n        peer.on('signal', (connectionInfo) => {\n            setMyConnectionString(JSON.stringify(connectionInfo));\n        });\n        // When the remote peer is connected\n        peer.on('connect', () => {\n            // Stop displaying the form\n            setIsConnected(true);\n            if (initiator) {\n                // Automatically route signals between invitees\n                dispatch({\n                    type : 'PEER_RELAY',\n                    id   : peer._id,\n                });\n            }\n        });\n        // Receive audio/video stream from remote peer\n        peer.on('stream', (stream) => {\n            dispatch({\n                type : 'STREAMS_ADD',\n                id   : peer._id,\n                stream\n            });\n        });\n        peer.on('error', (error) => {\n            console.error('Peer error:', error);\n        });\n        addRelayListeners(peer, state, dispatch);\n        dispatch({\n            type : 'PEERS_ADD',\n            // The ID of the direct connections won't match across machines, but\n            // that doesn't matter because no signals need to be routed for them.\n            id   : peer._id,\n            peer\n        });\n        // Save the peer for this component so we can signal on form submit\n        setThem(peer);\n    }, []);\n\n    if (isConnected) return null;\n\n    const connectToOther = (event) => {\n        event.preventDefault();\n        them.signal(JSON.parse(theirConnectionString));\n    };\n\n    // Form logic is different if you're the initiator of the offer\n    // or responding to the offer with an answer\n    const myConnectionLabel = initiator ?\n        'Send this connection info to your friend' :\n        'Reply to your friend with your connection info';\n    const theirConnectionLabel = initiator ?\n        'Your friend should reply with their own connection info, paste it here' :\n        'Paste the connection info sent from your friend here';\n    const myConnectionField = <label key=\"my-connection\">\n        { myConnectionLabel }:\n        <textarea readOnly value={myConnectionString} />\n    </label>;\n    const theirConnectionField = <label key=\"their-connection\">\n        { theirConnectionLabel }:\n        <textarea\n            onChange={(event) => setTheirConnectionString(event.target.value)}\n            value={theirConnectionString}\n        />\n    </label>;\n    const submitButton = <input key=\"connect\" type=\"submit\" value=\"Connect!\" />;\n    const connectionFields = [];\n    if (initiator) {\n        if (myConnectionString) {\n            connectionFields.push(myConnectionField, theirConnectionField, submitButton);\n        } else {\n            connectionFields.push('Generating connection info...');\n        }\n    } else {\n        connectionFields.push(theirConnectionField, submitButton);\n        // The responder has to hit connect first to generate their answer\n        if (myConnectionString) {\n            connectionFields.push(myConnectionField);\n        }\n    }\n\n    return <form onSubmit={connectToOther}>\n        { connectionFields }\n    </form>;\n};\n\nexport default AddPeer;\n","import React, { useContext, useState } from 'react';\nimport AddPeer from './AddPeer';\nimport { Context } from './Store';\nimport './AddPeers.css';\n\nconst AddPeers = () => {\n    const [state] = useContext(Context);\n    const { initiator } = state;\n    const [pendingConnections, setPendingConnections] = useState([\n        <AddPeer key={0} />\n    ]);\n\n    const addNewConnection = () => {\n        setPendingConnections([\n            ...pendingConnections,\n            <AddPeer key={pendingConnections.length} />\n        ]);\n    };\n\n    return (\n        <div className=\"pending-connections\">\n            { pendingConnections }\n            { initiator &&\n                <button onClick={addNewConnection}>Invite another friend</button> }\n        </div>\n    );\n};\n\nexport default AddPeers;\n","import React, { useContext } from 'react';\nimport { Context } from './Store';\n\nconst AudioVideoSetup = () => {\n    const [, dispatch] = useContext(Context);\n\n    // TODO: allow choice of audio/video input\n    const getPermission = () => {\n        // Ask for webcam/microphone permission\n        navigator.mediaDevices.getUserMedia({\n            audio : true,\n            video : true\n        }).then((stream) => {\n            dispatch({\n                type : 'MY_STREAM_SET',\n                stream\n            });\n        });\n    };\n\n    return <section>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video.</div>\n        <button onClick={getPermission}>Let's go!</button>\n    </section>\n};\n\nexport default AudioVideoSetup;\n","import React, { useCallback } from 'react';\n\nconst VideoSquare = ({ muted = false, stream }) => {\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if ('srcObject' in node) {\n                node.srcObject = stream;\n            } else {\n                node.src = URL.createObjectURL(stream);\n            }\n        }\n    }, [stream]);\n    return stream && <video autoPlay muted={muted} ref={videoRef} />;\n};\n\nexport default VideoSquare;\n","import React, { useContext } from 'react';\nimport AddPeers from './AddPeers';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\nimport './GreenRoom.css';\n\nconst GreenRoom = () => {\n    const [state] = useContext(Context);\n    console.log('STATE', state);\n    const { myStream, streams } = state;\n\n    return <>\n        <div className=\"videos\">\n            { myStream ?\n                <VideoSquare muted stream={myStream} /> :\n                <AudioVideoSetup /> }\n            { Object.entries(streams).map(([id, stream]) => {\n                return <VideoSquare key={id} stream={stream} />;\n            }) }\n        </div>\n        { myStream && <AddPeers /> }\n\n    </>;\n};\n\nexport default GreenRoom;\n","import React from 'react';\nimport GreenRoom from './GreenRoom';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <GreenRoom />\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}