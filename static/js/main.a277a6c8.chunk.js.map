{"version":3,"sources":["state/reducer.js","components/Store.jsx","components/VideoSquare/InputOutputSelect.jsx","components/VideoSquare/AudioVideoSetup.jsx","components/VideoSquare/index.jsx","components/GreenRoom.jsx","state/use-previous.js","components/App.js","serviceWorker.js","index.js"],"names":["initialState","myId","myStream","order","peers","server","streams","videoElements","sendToServer","data","send","JSON","stringify","reducer","state","action","console","log","type","id","oldStream","newStream","stream","Object","values","forEach","peer","removeStream","addStream","replacePeerStreams","fromId","dispatch","parse","forId","theirId","receiveSignal","signal","initiator","isNewPeer","keys","includes","Peer","on","theirStream","handleServerMessage","videoElement","error","Context","createContext","Store","children","useReducer","Provider","value","InputOutputSelect","useContext","useState","devices","setDevices","showSetup","setShowSetup","audioInput","setAudioInput","audioOutput","setAudioOutput","videoInput","setVideoInput","setStream","a","getTracks","track","stop","navigator","mediaDevices","getUserMedia","audio","autoGainControl","exact","deviceId","echoCancellation","noiseSuppression","video","AudioContext","window","webkitAudioContext","audioCtx","createMediaStreamSource","connect","destination","useEffect","enumerateDevices","deviceList","findDevices","nodes","length","setSinkId","kinds","kindLabels","selectedDevices","devicesSorted","reduce","accumulator","device","kind","index","indexOf","slice","map","deviceMap","devicesOfType","label","selectedDeviceId","setSelectedDeviceId","key","onChange","event","target","onClick","AudioVideoSetup","showWelcome","setShowWelcome","welcomeMessage","style","alignItems","display","flexDirection","bottom","justifyContent","position","VideoSquare","isMe","numColumns","videoRef","useCallback","node","srcObject","src","URL","createObjectURL","dndRef","useRef","useDrag","item","collect","monitor","isDragging","connectDrag","useDrop","accept","drop","hover","hoveredOverId","myIndex","theirIndex","newOrder","connectDrop","cascadeOrder","findIndex","otherId","row","Math","ceil","gridColumn","gridRow","opacity","ref","autoPlay","muted","left","top","GreenRoom","prevMyStream","prevRef","current","usePrevious","serverURL","URLSearchParams","location","search","get","WebSocket","addEventListener","numParticipants","cols","sqrt","rows","colPct","rowPct","gridStyles","gridTemplateColumns","gridTemplateRows","height","className","entries","App","DndProvider","backend","HTML5Backend","Boolean","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"qVAEaA,EAAe,CAExBC,KAAgB,KAEhBC,SAAgB,KAEhBC,MAAgB,GAGhBC,MAAgB,GAGhBC,OAAgB,KAGhBC,QAAgB,GAEhBC,cAAgB,IA8EpB,SAASC,EAAaH,EAAQI,GAC1BJ,EAAOK,KAAKC,KAAKC,UAAUH,IAOhB,SAASI,EAAQC,EAAOC,GACnCC,QAAQC,IAAI,SAAUF,GADqB,IAEnCd,EAAiCa,EAAjCb,KAAME,EAA2BW,EAA3BX,MAAOE,EAAoBS,EAApBT,OAAQC,EAAYQ,EAAZR,QAC7B,OAAQS,EAAOG,MACX,IAAK,YACD,OAAO,eACAJ,EADP,CAEIb,KAAOc,EAAOI,KAEtB,IAAK,gBAED,OA9FZ,SAA4BL,EAAOC,GAAS,IACrBK,EAAqBN,EAAhCZ,SAAsBE,EAAUU,EAAVV,MACbiB,EAAcN,EAAvBO,OACRC,OAAOC,OAAOpB,GAAOqB,SAAQ,SAACC,GAC1BA,EAAKC,aAAaP,GAClBM,EAAKE,UAAUP,MAwFXQ,CAAmBf,EAAOC,GACnB,eACAD,EADP,CAEIZ,SAAWa,EAAOO,SAG1B,IAAK,aAMD,OALAd,EAAaH,EAAQ,CACjBa,KAAS,QACTY,OAAS7B,EACTE,UAEGW,EAEX,IAAK,YACD,OAAO,eACAA,EADP,CAEIX,MAAQY,EAAOZ,QAEvB,IAAK,iBACD,OAxGZ,SAA6BW,EAAOC,GAAS,IACjCb,EAA4BY,EAA5BZ,SAAUE,EAAkBU,EAAlBV,MAAOC,EAAWS,EAAXT,OAEjBI,EAAmBM,EAAnBN,KAAMsB,EAAahB,EAAbgB,SAH0B,EAUpCpB,KAAKqB,MAAMvB,GALFR,EAL2B,EAKpCgC,MACSC,EAN2B,EAMpCJ,OACA3B,EAPoC,EAOpCA,MACSgC,EAR2B,EAQpCC,OACAlB,EAToC,EASpCA,KAEJ,GAAa,OAATA,EACAa,EAAS,CACLb,KAAO,YACPC,GAAOlB,SAER,GAAa,UAATiB,EACPa,EAAS,CACLb,KAAO,YACPf,eAED,GAAa,WAATe,EAAmB,CAC1B,IAAMmB,EAA8B,aAAlBF,EACZG,GAAaf,OAAOgB,KAAKnC,GAAOoC,SAASN,GACzCR,EAAOY,EACT,IAAIG,IAAK,CACLJ,YACAf,OAASpB,IAEbE,EAAM8B,GAuBV,GAtBII,IACAZ,EAAKgB,GAAG,UAAU,SAACN,GACf5B,EAAaH,EAAQ,CACjBa,KAAS,SACTe,MAASC,EACTJ,OAAS7B,EACTmC,cAGRV,EAAKgB,GAAG,UAAU,SAACC,GACfZ,EAAS,CACLb,KAAS,cACTC,GAASe,EACTZ,OAASqB,QAKhBN,GACDX,EAAKU,OAAOD,GAGZG,EACA,OAAO,eACAxB,EADP,CAEIV,MAAK,eACEA,EADF,eAEA8B,EAAWR,MAM5B,OAAOZ,EAyCQ8B,CAAoB9B,EAAOC,GACtC,IAAK,aACD,OAAO,eACAD,EADP,CAEIT,OAASU,EAAOV,SAExB,IAAK,cACD,OAAO,eACAS,EADP,CAEIR,QAAO,eACAA,EADA,eAGFS,EAAOI,GAAMJ,EAAOO,WAGjC,IAAK,oBACD,OAAO,eACAR,EADP,CAEIP,cAAa,eACRQ,EAAOI,GAAMJ,EAAO8B,gBAGjC,QAEI,OADA7B,QAAQ8B,MAAM,kBAAmB/B,GAC1BD,GC5JnB,IASaiC,EAAUC,wBAAchD,GACtBiD,EAVD,SAAC,GAAkB,IAAhBC,EAAe,EAAfA,SAAe,EACFC,qBAAWtC,EAASb,GADlB,mBACrBc,EADqB,KACdiB,EADc,KAE5B,OACI,kBAACgB,EAAQK,SAAT,CAAkBC,MAAO,CAACvC,EAAOiB,IAC5BmB,I,iDC2GEI,EA/GW,WAAO,IAAD,EACFC,qBAAWR,GADT,mBACrBjC,EADqB,KACdiB,EADc,KAEpB7B,EAA4BY,EAA5BZ,SAAUK,EAAkBO,EAAlBP,cAFU,EAGEiD,mBAAS,IAHX,mBAGrBC,EAHqB,KAGZC,EAHY,OAIMF,oBAAS,GAJf,mBAIrBG,EAJqB,KAIVC,EAJU,OAKQJ,mBAAS,MALjB,mBAKrBK,EALqB,KAKTC,EALS,OAMUN,mBAAS,MANnB,mBAMrBO,EANqB,KAMRC,EANQ,OAOQR,mBAAS,MAPjB,mBAOrBS,EAPqB,KAOTC,EAPS,KAStBC,EAAS,uCAAG,gCAAAC,EAAA,6DACVlE,GACAA,EAASmE,YAAY5C,SAAQ,SAAC6C,GAAD,OAAWA,EAAMC,UAFpC,SAIOC,UAAUC,aAAaC,aAAa,CACrDC,MAAQ,CACJC,gBAAmB,CAAEC,OAAQ,GAC7BC,SAAmBjB,GAAc,CAC7BgB,MAAQhB,GAEZkB,kBAAmB,EACnBC,iBAAmB,CAAEH,OAAQ,IAEjCI,MAAQ,CACJH,SAAWb,GAAc,CACrBY,MAAQZ,MAfN,OAIR3C,EAJQ,OAoBR4D,EAAeC,OAAOD,cAAgBC,OAAOC,mBAC7CC,EAAW,IAAIH,EACNG,EAASC,wBAAwBhE,GACzCiE,QAAQF,EAASG,aACxBzD,EAAS,CACLb,KAAO,gBACPI,WA1BU,2CAAH,qDA8BfmE,qBAAU,WAIFvF,GAAYyD,GACK,uCAAG,4BAAAS,EAAA,sEACSI,UAAUC,aAAaiB,mBADhC,OACVC,EADU,OAEhBjC,EAAWiC,GAFK,2CAAH,oDAIjBC,KAEL,CAAC1F,EAAUyD,IAEd8B,qBAAU,WAGNtB,MACD,CAACN,EAAYI,IAEhBwB,qBAAU,WACN,IAAMI,EAAQtE,OAAOC,OAAOjB,GACxBsF,EAAMC,QAAU/B,GAChB8B,EAAME,UAAUhC,KAErB,CAACA,EAAaxD,IAEjB,IAAMyF,EAAQ,CAAC,aAAc,cAAe,cACtCC,EAAa,CAAC,cAAe,eAAgB,eAC7CC,EAAkB,CACpB,CAACrC,EAAYC,GACb,CAACC,EAAaC,GACd,CAACC,EAAYC,IAGXiC,EAAgB1C,EAAQ2C,QAAO,SAACC,EAAaC,GAAY,IACnDxB,EAAmBwB,EAAnBxB,SAAUyB,EAASD,EAATC,KACZC,EAAQR,EAAMS,QAAQF,GAC5B,MAAM,GAAN,mBACOF,EAAYK,MAAM,EAAGF,IAD5B,gBAGWH,EAAYG,GAHvB,eAIS1B,EAAYwB,KAJrB,YAMOD,EAAYK,MAAMF,EAAQ,OAElC,CAAC,GAAI,GAAI,KAEZ,OAAO7C,EAAY,oCACbwC,EAAcQ,KAAI,SAACC,EAAWJ,GAC5B,IAAMK,EAAgBtF,OAAOC,OAAOoF,GACpC,GAA6B,IAAzBC,EAAcf,OAAc,OAAO,KACvC,IAAMgB,EAAQb,EAAWO,GAHa,cAIUN,EAAgBM,GAJ1B,GAI/BO,EAJ+B,KAIbC,EAJa,KAKtC,OACI,2BAAOC,IAAKH,GACPA,EACD,4BACII,SAAU,SAACC,GAAD,OAAWH,EAAoBG,EAAMC,OAAO/D,QACtDA,MAAO0D,GAAoB,WAEzBF,EAAcF,KAAI,gBAAG7B,EAAH,EAAGA,SAAUgC,EAAb,EAAaA,MAAb,OAChB,4BAAQG,IAAKnC,EAAUzB,MAAOyB,GAAWgC,WAM7D,4BAAQO,QAAS,kBAAMzD,GAAa,KAApC,MAEJ,4BAAQyD,QAAS,kBAAMzD,GAAa,KAApC,yBC5EW0D,EAhCS,WAAO,IAAD,EACY9D,oBAAS,GADrB,mBACnB+D,EADmB,KACNC,EADM,KAGpBC,EAAiB,oCACnB,qEACA,2IACA,4BAAQJ,QAAS,kBAAMG,GAAe,KAAtC,cAUEE,EAAK,aACPC,WAAgB,SAChBC,QAAgB,OAChBC,cAAgBN,EAAc,SAAW,OACrCA,EAAc,GATK,CACvBO,OAAiB,EACjBC,eAAiB,gBACjBC,SAAiB,aASrB,OACI,6BAASN,MAAOA,GACVH,EACEE,EACA,kBAAC,EAAD,QCkDDQ,EA3EK,SAAC,GAAsC,IAApC9G,EAAmC,EAAnCA,GAAI+G,EAA+B,EAA/BA,KAAMC,EAAyB,EAAzBA,WAAY7G,EAAa,EAAbA,OAAa,EAC5BiC,qBAAWR,GADiB,mBAC/CjC,EAD+C,KACxCiB,EADwC,KAE9C5B,EAAUW,EAAVX,MAEFiI,EAAWC,uBAAY,SAACC,GACtBA,IACI,cAAeA,EACfA,EAAKC,UAAYjH,EAEjBgH,EAAKE,IAAMC,IAAIC,gBAAgBpH,GAI/B4G,GACAnG,EAAS,CACLb,KAAe,oBACfC,KACA0B,aAAeyF,OAI5B,CAAChH,IAEEqH,EAASC,iBAAO,MAvBgC,EAwBhBC,YAAQ,CAC1CC,KAAU,CAAE3H,KAAID,KAAO,eACvB6H,QAAU,SAACC,GAAD,MAAc,CAAEC,WAAaD,EAAQC,iBA1BG,mBAwB7CA,EAxB6C,KAwB7CA,WAAcC,EAxB+B,OA4B9BC,YAAQ,CAC5BC,OAAS,cACTC,KAAS,SAACP,GACN/G,EAAS,CAAEb,KAAO,gBAEtBoI,MAAS,YAA6B,IAArBC,EAAoB,EAAzBpI,GACR,GAAIoI,IAAkBpI,EAAI,CACtB,IAAMqI,EAAUrJ,EAAMsG,QAAQtF,GACxBsI,EAAatJ,EAAMsG,QAAQ8C,GAC3BG,EAAQ,YAAOvJ,GACrBuJ,EAASF,GAAWD,EACpBG,EAASD,GAActI,EACvBY,EAAS,CACLb,KAAQ,YACRf,MAAQuJ,QAdfC,EA5B6C,oBA+CtDT,EAAYP,GACZgB,EAAYhB,GAEZ,IAAMiB,EAAezJ,EAAM0J,WAAU,SAACC,GAAD,OAAa3I,IAAO2I,KAAW,EAC9DC,EAAMC,KAAKC,KAAKL,EAAezB,GAG/BT,EAAQ,CACVwC,WAAU,UAFFN,GADUG,EAAM,GAAK5B,EAGnB,aACVgC,QAAO,UAASJ,EAAT,aACPK,QAAanB,EAAa,GAAM,EAChCjB,SAAa,YAQjB,OACI,yBAAKqC,IAAK1B,EAAQjB,MAAOA,GACnBpG,GAAU,2BAAOgJ,UAAQ,EAACC,MAAOrC,EAAMmC,IAAKjC,IAC5CF,GAAQ,kBAAC,EAAD,MACR5G,GAAU,0BAAMoG,MAVN,CAChB8C,KAAW,EACXxC,SAAW,WACXyC,IAAW,IAOgCb,KCtEnD,IA+Dec,EA/DG,WAAO,IAAD,EACMnH,qBAAWR,GADjB,mBACbjC,EADa,KACNiB,EADM,KAEpBf,QAAQC,IAAI,QAASH,GAFD,IAGZb,EAAmCa,EAAnCb,KAAMC,EAA6BY,EAA7BZ,SAAUC,EAAmBW,EAAnBX,MAAOG,EAAYQ,EAAZR,QACzBqK,ECPK,SAAqBtH,GAChC,IAAMuH,EAAUhC,mBAIhB,OAHAnD,qBAAU,WACNmF,EAAQC,QAAUxH,IACnB,CAACA,IACGuH,EAAQC,QDEMC,CAAY5K,GAG3B6K,EADS,IAAIC,gBAAgB7F,OAAO8F,SAASC,QAC1BC,IAAI,UAyB7B,GAxBA1F,qBAAU,WAEN,GAAIvF,IAAayK,GAAgBI,EAAW,CAGxC,IAAM1K,EAAS,IAAI+K,UAAUL,GAC7B1K,EAAOgL,iBAAiB,SAAS,kBAAMrK,QAAQC,IAAI,qBACnDZ,EAAOgL,iBAAiB,SAAS,kBAAMrK,QAAQC,IAAI,mBACnDZ,EAAOgL,iBAAiB,QAAQ,kBAAMrK,QAAQC,IAAI,qBAClDZ,EAAOgL,iBAAiB,WAAW,YAAe,IAAZ5K,EAAW,EAAXA,KAClCsB,EAAS,CACLb,KAAO,iBACPT,OACAsB,gBAGRA,EAAS,CACLb,KAAO,aACPb,cAIT,CAACH,EAAUyK,EAAcI,KAEvBA,EACD,MAAO,+DAKX,IAAMO,EAAkBnL,EAAM2F,QAAU,EAGlCyF,EAAOvB,KAAKC,KAAKD,KAAKwB,KAAKF,IAC3BG,EAAOzB,KAAKC,KAAKqB,EAAkBC,GACnCG,EAAS,IAAMH,EACfI,EAAS,IAAMF,EACfG,EAAa,CACfhE,QAAsB,OACtBiE,oBAAmB,iBAAaN,EAAb,aAAsBG,EAAtB,MACnBI,iBAAgB,iBAAgBP,EAAhB,aAAyBI,EAAzB,MAChBI,OAAsB,QAI1B,OACI,0BAAMC,UAAU,SAAStE,MAAOkE,GAC5B,kBAAC,EAAD,CAAa1D,MAAI,EAAC/G,GAAIlB,EAAMkI,WAAYoD,EAAMjK,OAAQpB,IACpDqB,OAAO0K,QAAQ3L,GAASqG,KAAI,YAAmB,IAAD,mBAAhBxF,EAAgB,KAAZG,EAAY,KAC5C,OAAO,kBAAC,EAAD,CAAa2F,IAAK9F,EAAIA,GAAIA,EAAIgH,WAAYoD,EAAMjK,OAAQA,SE5ChE4K,G,MAXH,WAER,OACI,kBAAC,EAAD,KACI,kBAACC,EAAA,EAAD,CAAaC,QAASC,KAClB,kBAAC,EAAD,UCAIC,QACW,cAA7BnH,OAAO8F,SAASsB,UAEe,UAA7BpH,OAAO8F,SAASsB,UAEhBpH,OAAO8F,SAASsB,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,EAAD,MACAC,SAASC,eAAe,SD2HpB,kBAAmBpI,WACrBA,UAAUqI,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAApK,GACL9B,QAAQ8B,MAAMA,EAAMqK,c","file":"static/js/main.a277a6c8.chunk.js","sourcesContent":["import Peer from 'simple-peer';\n\nexport const initialState = {\n    // UUID generated by the server\n    myId          : null,\n    // MediaStream object containing audio/video\n    myStream      : null,\n    // The order of the participants - how the audios cascades\n    order         : [],\n    // Direct connections to other participants via WebRTC that provide the streams\n    // Keys are the server-generated IDs\n    peers         : {},\n    // WebSocket server connection to send the initial WebRTC signals\n    // (and a biiiit more after)\n    server        : null,\n    // MediaStream objects for remote peers\n    // Keys are the server-generated IDs\n    streams       : {},\n    // These have to be stored to set audio output as the dropdown changes\n    videoElements : {}\n};\n\nfunction replacePeerStreams(state, action) {\n    const { myStream : oldStream, peers } = state;\n    const { stream : newStream } = action;\n    Object.values(peers).forEach((peer) => {\n        peer.removeStream(oldStream)\n        peer.addStream(newStream);\n    });\n}\n\nfunction handleServerMessage(state, action) {\n    const { myStream, peers, server } = state;\n    // Sending dispatch in the action is kind of a hack...\n    const { data, dispatch } = action;\n    const {\n        forId  : myId,\n        fromId : theirId,\n        order,\n        signal : receiveSignal,\n        type\n    } = JSON.parse(data);\n    if (type === 'id') {\n        dispatch({\n            type : 'MY_ID_SET',\n            id   : myId,\n        });\n    } else if (type === 'order') {\n        dispatch({\n            type : 'ORDER_SET',\n            order\n        });\n    } else if (type === 'signal') {\n        const initiator = receiveSignal === 'initiate';\n        const isNewPeer = !Object.keys(peers).includes(theirId);\n        const peer = isNewPeer ?\n            new Peer({\n                initiator,\n                stream : myStream,\n            }) :\n            peers[theirId];\n        if (isNewPeer) {\n            peer.on('signal', (signal) => {\n                sendToServer(server, {\n                    type   : 'signal',\n                    forId  : theirId,\n                    fromId : myId,\n                    signal\n                });\n            });\n            peer.on('stream', (theirStream) => {\n                dispatch({\n                    type   : 'STREAMS_ADD',\n                    id     : theirId,\n                    stream : theirStream\n                });\n            });\n        }\n\n        if (!initiator) {\n            peer.signal(receiveSignal);\n        }\n\n        if (isNewPeer) {\n            return {\n                ...state,\n                peers : {\n                    ...peers,\n                    [theirId] : peer\n                }\n            };\n        }\n    }\n\n    return state;\n}\n\nfunction sendToServer(server, data) {\n    server.send(JSON.stringify(data));\n}\n\n// This reducer is not quite a pure function and I'm not sorry about it.\n// The SERVER_MESSAGE action will sometimes not mutate state but just call peer.signal().\n// Basically I'm hijacking the reducer to get the current state\n// when a message is received from the server.\nexport default function reducer(state, action) {\n    console.log('ACTION', action);\n    const { myId, order, server, streams } = state;\n    switch (action.type) {\n        case 'MY_ID_SET':\n            return {\n                ...state,\n                myId : action.id\n            };\n        case 'MY_STREAM_SET': {\n            replacePeerStreams(state, action);\n            return {\n                ...state,\n                myStream : action.stream\n            };\n        }\n        case 'ORDER_SEND': {\n            sendToServer(server, {\n                type   : 'order',\n                fromId : myId,\n                order\n            });\n            return state;\n        }\n        case 'ORDER_SET':\n            return {\n                ...state,\n                order : action.order\n            };\n        case 'SERVER_MESSAGE':\n            return handleServerMessage(state, action)\n        case 'SERVER_SET':\n            return {\n                ...state,\n                server : action.server\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams : {\n                    ...streams,\n                    // This ID matches the peer ID\n                    [action.id] : action.stream,\n                }\n            };\n        case 'VIDEO_ELEMENT_SET':\n            return {\n                ...state,\n                videoElements : {\n                    [action.id] : action.videoElement\n                }\n            };\n        default: {\n            console.error('Unknown action:', action);\n            return state;\n        }\n    }\n};\n","import React, { createContext, useReducer } from 'react';\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\n\nconst InputOutputSelect = () => {\n    const [state, dispatch] = useContext(Context);\n    const { myStream, videoElements } = state;\n    const [devices, setDevices] = useState([]);\n    const [showSetup, setShowSetup] = useState(false);\n    const [audioInput, setAudioInput] = useState(null);\n    const [audioOutput, setAudioOutput] = useState(null);\n    const [videoInput, setVideoInput] = useState(null);\n\n    const setStream = async () => {\n        if (myStream) {\n            myStream.getTracks().forEach((track) => track.stop());\n        }\n        const stream = await navigator.mediaDevices.getUserMedia({\n            audio : {\n                autoGainControl  : { exact : false },\n                deviceId         : audioInput && {\n                    exact : audioInput\n                },\n                echoCancellation : false,\n                noiseSuppression : { exact : false },\n            },\n            video : {\n                deviceId : videoInput && {\n                    exact : videoInput\n                }\n            }\n        });\n        // Safari, what the hell.\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioCtx = new AudioContext();\n        const source = audioCtx.createMediaStreamSource(stream);\n        source.connect(audioCtx.destination);\n        dispatch({\n            type : 'MY_STREAM_SET',\n            stream\n        });\n    };\n\n    useEffect(() => {\n        // On Safari, enumerateDevices only works after getUserMedia is called.\n        // So wait for that to happen before populating the dropdowns.\n        // (Also, missing things even after it's called...)\n        if (myStream && showSetup) {\n            const findDevices = async () => {\n                const deviceList = await navigator.mediaDevices.enumerateDevices();\n                setDevices(deviceList);\n            };\n            findDevices();\n        }\n    }, [myStream, showSetup]);\n\n    useEffect(() => {\n        // Called on the first render\n        // (and any time audioInput or videoInput change)\n        setStream();\n    }, [audioInput, videoInput]);\n\n    useEffect(() => {\n        const nodes = Object.values(videoElements);\n        if (nodes.length && audioOutput) {\n            nodes.setSinkId(audioOutput);\n        }\n    }, [audioOutput, videoElements]);\n\n    const kinds = ['audioinput', 'audiooutput', 'videoinput'];\n    const kindLabels = ['Audio Input', 'Audio Output', 'Video Input'];\n    const selectedDevices = [\n        [audioInput, setAudioInput],\n        [audioOutput, setAudioOutput],\n        [videoInput, setVideoInput]\n    ];\n    // Sort the available devices into the three buckets\n    const devicesSorted = devices.reduce((accumulator, device) => {\n        const { deviceId, kind } = device;\n        const index = kinds.indexOf(kind);\n        return [\n            ...accumulator.slice(0, index),\n            {\n                ...accumulator[index],\n                [deviceId] : device,\n            },\n            ...accumulator.slice(index + 1)\n        ]\n    }, [{}, {}, {}]);\n\n    return showSetup ? <>\n        { devicesSorted.map((deviceMap, index) => {\n            const devicesOfType = Object.values(deviceMap);\n            if (devicesOfType.length === 0) return null;\n            const label = kindLabels[index];\n            const [selectedDeviceId, setSelectedDeviceId] = selectedDevices[index];\n            return (\n                <label key={label}>\n                    {label}\n                    <select\n                        onChange={(event) => setSelectedDeviceId(event.target.value)}\n                        value={selectedDeviceId || 'default'}\n                    >\n                        { devicesOfType.map(({ deviceId, label }) => (\n                            <option key={deviceId} value={deviceId}>{label}</option>\n                        )) }\n                    </select>\n                </label>\n            );\n        }) }\n        <button onClick={() => setShowSetup(false)}>x</button>\n    </> :\n    <button onClick={() => setShowSetup(true)}>Audio/Video settings</button>;\n};\n\nexport default InputOutputSelect;\n","import React, { useState } from 'react';\nimport InputOutputSelect from './InputOutputSelect';\n\nconst AudioVideoSetup = () => {\n    const [showWelcome, setShowWelcome] = useState(true);\n\n    const welcomeMessage = <>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video. Before you click the button, put on headphones so there's no feedback!</div>\n        <button onClick={() => setShowWelcome(false)}>\n            Let's go!\n        </button>\n    </>;\n\n    const afterWelcomeStyles = {\n        bottom         : 0,\n        justifyContent : 'space-between',\n        position       : 'absolute'\n    };\n    const style = {\n        alignItems    : 'center',\n        display       : 'flex',\n        flexDirection : showWelcome ? 'column' : 'row',\n        ...(showWelcome ? {} : afterWelcomeStyles)\n    };\n\n    return (\n        <section style={style}>\n            { showWelcome ?\n                welcomeMessage :\n                <InputOutputSelect /> }\n        </section>\n    );\n};\n\nexport default AudioVideoSetup;\n","import React, { useCallback, useContext, useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport { Context } from '../Store';\n\nconst VideoSquare = ({ id, isMe, numColumns, stream }) => {\n    const [state, dispatch] = useContext(Context);\n    const { order } = state;\n\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if ('srcObject' in node) {\n                node.srcObject = stream;\n            } else {\n                node.src = URL.createObjectURL(stream);\n            }\n            // The video element must be available elsewhere\n            // to set audio output via setSinkId().\n            if (isMe) {\n                dispatch({\n                    type         : 'VIDEO_ELEMENT_SET',\n                    id,\n                    videoElement : node\n                });\n            }\n        }\n    }, [stream]);\n\n    const dndRef = useRef(null);\n    const [{ isDragging }, connectDrag] = useDrag({\n        item    : { id, type : 'participant' },\n        collect : (monitor) => ({ isDragging : monitor.isDragging() })\n    });\n    const [, connectDrop] = useDrop({\n        accept : 'participant',\n        drop   : (item) => {\n            dispatch({ type : 'ORDER_SEND' });\n        },\n        hover  : ({ id : hoveredOverId }) => {\n            if (hoveredOverId !== id) {\n                const myIndex = order.indexOf(id);\n                const theirIndex = order.indexOf(hoveredOverId);\n                const newOrder = [...order];\n                newOrder[myIndex] = hoveredOverId;\n                newOrder[theirIndex] = id;\n                dispatch({\n                    type  : 'ORDER_SET',\n                    order : newOrder\n                });\n            }\n        }\n    });\n    connectDrag(dndRef);\n    connectDrop(dndRef);\n\n    const cascadeOrder = order.findIndex((otherId) => id === otherId) + 1;\n    const row = Math.ceil(cascadeOrder / numColumns);\n    const numBeforeRow = (row - 1) * numColumns;\n    const col = cascadeOrder - numBeforeRow;\n    const style = {\n        gridColumn : `${col} / span 1`,\n        gridRow    : `${row} / span 1`,\n        opacity    : isDragging ? 0.5 : 1,\n        position   : 'relative'\n    };\n    const numberStyle = {\n        left     : 0,\n        position : 'absolute',\n        top      : 0\n    };\n\n    return (\n        <div ref={dndRef} style={style}>\n            { stream && <video autoPlay muted={isMe} ref={videoRef} /> }\n            { isMe && <AudioVideoSetup /> }\n            { stream && <span style={numberStyle}>{cascadeOrder}</span> }\n        </div>\n    );\n};\n\nexport default VideoSquare;\n","import React, { useContext, useEffect } from 'react';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\nimport usePrevious from '../state/use-previous';\n\nconst GreenRoom = () => {\n    const [state, dispatch] = useContext(Context);\n    console.log('STATE', state);\n    const { myId, myStream, order, streams } = state;\n    const prevMyStream = usePrevious(myStream);\n\n    const params = new URLSearchParams(window.location.search);\n    const serverURL = params.get('server');\n    useEffect(() => {\n        // Start the server connection only when myStream is first initiated\n        if (myStream && !prevMyStream && serverURL) {\n            // We set the server connection here because\n            // we need access to dispatch in the event listeners.\n            const server = new WebSocket(serverURL);\n            server.addEventListener('close', () => console.log('closing socket'));\n            server.addEventListener('error', () => console.log('socket error'));\n            server.addEventListener('open', () => console.log('opening socket'));\n            server.addEventListener('message', ({ data }) => {\n                dispatch({\n                    type : 'SERVER_MESSAGE',\n                    data,\n                    dispatch\n                });\n            });\n            dispatch({\n                type : 'SERVER_SET',\n                server\n            });\n            // TODO: handle failed connection\n        }\n    }, [myStream, prevMyStream, serverURL]);\n\n    if (!serverURL) {\n        return \"You have to have a server. Sorry, that's just the way it is.\";\n    }\n\n    // Order comes from the server -\n    // but before connecting to the server, there is still 1 participant!\n    const numParticipants = order.length || 1;\n    // Add a new row when the number of participants exceeds the perfect square\n    // (2-4 partcipants have two columns, 5-9 have three columns, 10-16 have four columns, etc)\n    const cols = Math.ceil(Math.sqrt(numParticipants));\n    const rows = Math.ceil(numParticipants / cols);\n    const colPct = 100 / cols;\n    const rowPct = 100 / rows;\n    const gridStyles = {\n        display             : 'grid',\n        gridTemplateColumns : `repeat(${cols}, ${colPct}%)`,\n        gridTemplateRows    : `repeat(${cols}, ${rowPct}%)`,\n        height              : '100%',\n        // justifyItems        : 'center' // div is larger than video width...\n    };\n\n    return (\n        <main className=\"videos\" style={gridStyles}>\n            <VideoSquare isMe id={myId} numColumns={cols} stream={myStream} />\n            { Object.entries(streams).map(([id, stream]) => {\n                return <VideoSquare key={id} id={id} numColumns={cols} stream={stream} />;\n            }) }\n        </main>\n    );\n};\n\nexport default GreenRoom;\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious(value) {\n    const prevRef = useRef();\n    useEffect(() => {\n        prevRef.current = value;\n    }, [value]);\n    return prevRef.current;\n}\n","import React from 'react';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport GreenRoom from './GreenRoom';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <DndProvider backend={HTML5Backend}>\n                <GreenRoom />\n            </DndProvider>\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}