{"version":3,"sources":["state/modes.js","state/record-actions.js","state/reducer.js","components/Store.jsx","components/VideoSquare/AudioVideoSetup.jsx","state/peer-actions.js","state/cascade-actions.js","components/VideoSquare/Countdown.jsx","state/use-previous.js","components/VideoSquare/index.jsx","components/Welcome.jsx","components/GreenRoom.jsx","components/ServerProvider.jsx","components/App.js","serviceWorker.js","index.js"],"names":["READY","CASCADE_DONE","makeNewRecorder","stream","dispatch","recorder","MediaRecorder","mimeType","addEventListener","data","type","file","URL","createObjectURL","initialState","audioOutput","files","iAmInitiator","mode","myId","myStream","order","peers","server","streams","evilBoogiemanGlobalState","getState","serverSend","sendAction","send","JSON","stringify","reduceAndSave","state","action","newState","console","log","deviceId","concat","newMode","newStreams","id","newOrder","findIndex","otherId","peer","error","reducer","Context","createContext","Store","children","useReducer","Provider","value","audioCtx","window","AudioContext","webkitAudioContext","AudioVideoSetup","useContext","useState","devices","setDevices","showSetup","setShowSetup","audioInput","setAudioInput","videoInput","setVideoInput","setStream","a","navigator","mediaDevices","getUserMedia","audio","exact","autoGainControl","echoCancellation","noiseSuppression","video","getTracks","forEach","track","stop","Object","values","removeStream","addStream","createMediaStreamSource","connect","destination","useEffect","enumerateDevices","deviceList","findDevices","kinds","kindLabels","selectedDevices","devicesSorted","reduce","accumulator","device","kind","index","indexOf","slice","className","map","deviceMap","devicesOfType","length","label","selectedDeviceId","setSelectedDeviceId","key","onChange","event","target","onClick","makeNewPeer","initiator","newId","Peer","on","signal","forId","fromId","theirStream","cascade","audioTracks","getAudioTracks","videoTracks","getVideoTracks","myIndex","tracks","filter","Boolean","MediaStream","setStreamsFromCascade","changeMode","cloneMyStream","parse","toString","startTime","rest","printLatencyInfo","roundTripLatency","Date","now","latencies","push","pingPeer","getNextPeer","nextIndex","latencyInfo","avgPingTime","numPings","stdDevPingTime","toId","fromOrderNumber","toOrderNumber","cloneTracks","clone","stopStreaming","nextPeer","gatherLatencyInfo","myTracks","otherTracks","cascadeStream","sendCascadeStream","start","newMyStream","resetStreams","pingTime","sumOfSquares","Math","pow","sqrt","toIndex","initiatorId","sendLatencyInfo","Countdown","number","setNumber","setTimeout","usePrevious","prevRef","useRef","current","VideoSquare","numColumns","isMe","prevStream","prevAudioOutput","videoRef","useCallback","node","srcObject","src","setSinkId","dndRef","useDrag","item","canDrag","includes","collect","monitor","isDragging","connectDrag","useDrop","accept","drop","hover","hoveredOverId","theirIndex","connectDrop","orderNumber","row","ceil","gridStyle","gridColumn","gridRow","opacity","orderNumberStyle","backgroundColor","ref","style","autoPlay","muted","Welcome","GreenRoom","showWelcome","setShowWelcome","numParticipants","cols","rows","colPct","rowPct","gridStyles","gridTemplateColumns","gridTemplateRows","entries","startCascade","stopCascade","blobURL","download","href","ServerProvider","prevMyStream","serverURL","URLSearchParams","location","search","get","WebSocket","oldOrder","checkForNewPeers","handlePeerSignal","App","DndProvider","backend","HTML5Backend","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.2dc17563.chunk.js","sourcesContent":["// User is connecting audio/video, hasn't connected to server\nexport const SETUP = 0;\n// Connected to server, waiting for initiator to press GO\nexport const READY = 1;\n// Cascade has started but recording hasn't started yet.\n// For initiator, there's a short countdown.\n// For everyone else, it's just waiting on the stream to arrive.\nexport const CASCADE_STANDBY = 2;\n// Cascade in progress!\n// This will end for the initiator when they press the DONE button\n// and for everyone else when the stream ends.\nexport const CASCADE_RECORDING = 3;\n// After the cascade is finished, restarting connections needs to be handled differently.\n// Upstream peers should only send their video downstream after the downstream peers have finished.\nexport const CASCADE_DONE = 4;\n","export function makeNewRecorder(stream, dispatch) {\n    // TODO: use specific codecs. check browser compatibility.\n    const recorder = new MediaRecorder(stream, { mimeType : 'video/webm' });\n    recorder.addEventListener('dataavailable', ({ data }) => {\n        dispatch({\n            type : 'FILES_ADD',\n            file : URL.createObjectURL(data),\n        });\n    });\n    return recorder;\n}\n","import { CASCADE_STANDBY, READY, SETUP } from './modes';\nimport { makeNewRecorder } from './record-actions';\n\nexport const initialState = {\n    // This needs to be stored here so all video elements output sound to the same place.\n    audioOutput   : null,\n    // Blob URLs of the recorded myStream (not combined with other peers)\n    files         : [],\n    // The initiator is whoever is in the first spot.\n    // They have all the power. They get to rearrange the order of the cascade.\n    // And they press the big GO button.\n    iAmInitiator  : false,\n    mode          : SETUP,\n    // UUID generated by the server\n    myId          : null,\n    // MediaStream object containing audio/video\n    myStream      : null,\n    // The order of the participants - how the audios cascades\n    order         : [],\n    // Direct connections to other participants via WebRTC that provide the streams\n    // Keys are the server-generated IDs\n    peers         : {},\n    // Records myStream during cascade\n    recorder      : null,\n    // WebSocket server connection to send the initial WebRTC signals (and a biiiit more after)\n    server        : null,\n    // MediaStream objects for remote peers\n    // Keys are the server-generated IDs\n    streams       : {}\n};\n\nfunction reducer(state, action) {\n    console.log('ACTION', action);\n    const { files, mode, myId, myStream, peers, streams } = state;\n    switch (action.type) {\n        case 'AUDIO_OUTPUT_SET':\n            return {\n                ...state,\n                audioOutput : action.deviceId\n            };\n        case 'FILES_ADD':\n            return {\n                ...state,\n                files : files.concat(action.file)\n            };\n        case 'MODE_SET': {\n            const { mode : newMode } = action;\n            // When starting the cascade, remove the streams\n            // (which will be stopped shortly)\n            const newStreams = newMode === CASCADE_STANDBY ? {} : streams;\n            return {\n                ...state,\n                mode    : newMode,\n                streams : newStreams\n            };\n        }\n        case 'MY_ID_SET':\n            return {\n                ...state,\n                myId : action.id\n            };\n        case 'MY_STREAM_SET': {\n            // Move from setup mode when myStream is first set\n            const newMode = myStream ? mode : READY;\n            return {\n                ...state,\n                mode     : newMode,\n                myStream : action.stream,\n                recorder : makeNewRecorder(action.stream, action.dispatch)\n            };\n        }\n        case 'ORDER_SET': {\n            const { order : newOrder } = action;\n            const myOrderIndex = newOrder.findIndex((otherId) => myId === otherId);\n            const iAmInitiator = myOrderIndex === 0;\n            return {\n                ...state,\n                iAmInitiator,\n                order : newOrder\n            };\n        }\n        case 'PEERS_ADD':\n            return {\n                ...state,\n                peers : {\n                    ...peers,\n                    [action.id] : action.peer\n                }\n            };\n        case 'SERVER_SET':\n            return {\n                ...state,\n                server : action.server\n            };\n        case 'STREAMS_ADD':\n            return {\n                ...state,\n                streams : {\n                    ...streams,\n                    [action.id] : action.stream\n                }\n            };\n        default: {\n            console.error('Unknown action:', action);\n            return state;\n        }\n    }\n};\n\nlet evilBoogiemanGlobalState = {};\nexport function getState() {\n    return evilBoogiemanGlobalState;\n}\n\nexport function serverSend(sendAction) {\n    const { server } = getState();\n    server.send(JSON.stringify(sendAction));\n}\n\nexport default function reduceAndSave(state, action) {\n    const newState = reducer(state, action);\n    evilBoogiemanGlobalState = newState;\n    return newState;\n}\n","import React, { createContext, useReducer } from 'react';\nimport reducer, { initialState } from '../state/reducer';\n\nconst Store = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n    return (\n        <Context.Provider value={[state, dispatch]}>\n            {children}\n        </Context.Provider>\n    )\n};\n\nexport const Context = createContext(initialState);\nexport default Store;\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\n\n// Safari, what the hell.\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nconst audioCtx = new AudioContext();\n\nconst AudioVideoSetup = () => {\n    const [state, dispatch] = useContext(Context);\n    const { audioOutput, myStream, peers } = state;\n    const [devices, setDevices] = useState([]);\n    const [showSetup, setShowSetup] = useState(false);\n    const [audioInput, setAudioInput] = useState(null);\n    const [videoInput, setVideoInput] = useState(null);\n    const setAudioOutput = (deviceId) => {\n        dispatch({\n            type : 'AUDIO_OUTPUT_SET',\n            deviceId\n        });\n    }\n\n    const setStream = async () => {\n        const stream = await navigator.mediaDevices.getUserMedia({\n            audio : {\n                deviceId         : audioInput && {\n                    exact : audioInput\n                },\n                // These cause latency\n                autoGainControl  : { exact : false },\n                echoCancellation : false,\n                noiseSuppression : { exact : false },\n            },\n            video : {\n                deviceId : videoInput && {\n                    exact : videoInput\n                }\n            }\n        });\n        if (myStream) {\n            myStream.getTracks().forEach((track) => track.stop());\n            Object.values(peers).forEach((peer) => {\n                peer.removeStream(myStream)\n                peer.addStream(stream);\n            });\n        }\n        // Strangely, there is a delay when hearing the audio via the video element.\n        // But the delay is noticeably shorter when using the Web Audio API...\n        // (But only in Chrome?)\n        const source = audioCtx.createMediaStreamSource(stream);\n        // TODO: set output properly. See:\n        // https://stackoverflow.com/questions/41863094/how-to-select-destination-output-device-using-web-audio-api\n        source.connect(audioCtx.destination);\n        dispatch({\n            type : 'MY_STREAM_SET',\n            // Need to dispatch in the recorder ondataavailable event listener\n            dispatch,\n            stream\n        });\n    };\n\n    useEffect(() => {\n        // On Safari, enumerateDevices only works after getUserMedia is called.\n        // So wait for that to happen before populating the dropdowns.\n        // (Also, missing things even after it's called...)\n        if (myStream && showSetup) {\n            const findDevices = async () => {\n                const deviceList = await navigator.mediaDevices.enumerateDevices();\n                setDevices(deviceList);\n            };\n            findDevices();\n        }\n    }, [myStream, showSetup]);\n\n    useEffect(() => {\n        // Called on the first render\n        // (and any time audioInput or videoInput change)\n        setStream();\n    }, [audioInput, videoInput]);\n\n    const kinds = ['audioinput', 'audiooutput', 'videoinput'];\n    const kindLabels = ['Audio Input', 'Audio Output', 'Video Input'];\n    const selectedDevices = [\n        [audioInput, setAudioInput],\n        [audioOutput, setAudioOutput],\n        [videoInput, setVideoInput]\n    ];\n    // Sort the available devices into the three buckets\n    const devicesSorted = devices.reduce((accumulator, device) => {\n        const { deviceId, kind } = device;\n        const index = kinds.indexOf(kind);\n        return [\n            ...accumulator.slice(0, index),\n            {\n                ...accumulator[index],\n                [deviceId] : device,\n            },\n            ...accumulator.slice(index + 1)\n        ]\n    }, [{}, {}, {}]);\n\n    return (\n        <section className=\"av-setup\">\n            { showSetup ? <>\n                { devicesSorted.map((deviceMap, index) => {\n                    const devicesOfType = Object.values(deviceMap);\n                    if (devicesOfType.length === 0) return null;\n                    const label = kindLabels[index];\n                    const [selectedDeviceId, setSelectedDeviceId] = selectedDevices[index];\n                    return (\n                        <label key={label}>\n                            {label}\n                            <select\n                                onChange={(event) => setSelectedDeviceId(event.target.value)}\n                                value={selectedDeviceId || 'default'}\n                            >\n                                { devicesOfType.map(({ deviceId, label }) => (\n                                    <option key={deviceId} value={deviceId}>{label}</option>\n                                )) }\n                            </select>\n                        </label>\n                    );\n                }) }\n                <button onClick={() => setShowSetup(false)}>x</button>\n            </> :\n            <button onClick={() => setShowSetup(true)}>Audio/Video settings</button> }\n        </section>\n    );\n};\n\nexport default AudioVideoSetup;\n","import Peer from 'simple-peer';\nimport { changeMode, cloneMyStream, setStreamsFromCascade } from './cascade-actions';\nimport { CASCADE_DONE, CASCADE_RECORDING, CASCADE_STANDBY } from './modes';\nimport { getState, serverSend } from './reducer';\n\nexport function checkForNewPeers(action, dispatch) {\n    const { order : newOrder } = action;\n    const { myId, order : oldOrder, peers } = getState();\n    dispatch(action);\n    // If receiving order for the first time,\n    // initialize a new peer for everyone else waiting\n    if (oldOrder.length === 0) {\n        newOrder.forEach((id) => {\n            if (id !== myId && !peers[id]) {\n                makeNewPeer(true, id, dispatch);\n            }\n        });\n    }\n}\n\nfunction makeNewPeer(initiator, newId, dispatch) {\n    const { myId, myStream } = getState();\n    const peer = new Peer({\n        initiator,\n        stream : myStream,\n    });\n\n    peer.on('signal', (signal) => {\n        serverSend({\n            type   : 'PEER_SIGNAL',\n            forId  : newId,\n            fromId : myId,\n            signal\n        });\n    });\n\n    peer.on('stream', (theirStream) => {\n        const { mode } = getState();\n        // In this mode, the stream is a cascade\n        // containing all the synchronized audio/video\n        // from all previous peers.\n        // Receiving it is a signal to start the cascade.\n        if (mode === CASCADE_STANDBY) {\n            setStreamsFromCascade(theirStream, dispatch);\n            changeMode(CASCADE_RECORDING, dispatch);\n        } else {\n            dispatch({\n                type   : 'STREAMS_ADD',\n                id     : newId,\n                stream : theirStream\n            });\n            // If a new stream is added while recording,\n            // that means the cascade is over\n            if (mode === CASCADE_RECORDING) {\n                changeMode(CASCADE_DONE, dispatch);\n            }\n            // After cascading, if this is sent from downstream,\n            // we need to reciprocate and reopen our stream as well\n            if (mode === CASCADE_DONE && peer.streams.length === 0) {\n                peer.addStream(cloneMyStream());\n            }\n        }\n    });\n\n    // The peer data channel is currently only used for sending\n    // pings to get an idea of the time it takes for a stream\n    // to reach the next person in the cascade\n    peer.on('data', (data) => {\n        const { mode } = getState();\n        const { startTime, type, ...rest } = JSON.parse(data.toString());\n        // This will go away when we send it to the server instead\n        if (type === 'latency_info') {\n            printLatencyInfo(rest);\n        }\n        // Send the ping right back\n        if (type === 'ping') {\n            peer.send(JSON.stringify({\n                type : 'ping_response',\n                startTime,\n            }));\n        }\n        // Keep pinging until recording starts\n        if (type === 'ping_response') {\n            const roundTripLatency = Date.now() - startTime;\n            latencies.push(roundTripLatency);\n            if (mode === CASCADE_STANDBY) {\n                pingPeer(peer);\n            }\n        }\n    });\n\n    dispatch({\n        type : 'PEERS_ADD',\n        id   : newId,\n        peer\n    });\n    return peer;\n}\n\nexport function handlePeerSignal(action, dispatch) {\n    const { peers } = getState();\n    const { fromId, signal } = action;\n    const existingPeer = peers[fromId];\n    const peer = existingPeer || makeNewPeer(false, fromId, dispatch);\n    peer.signal(signal);\n}\n\nexport function getNextPeer(state) {\n    const { myId, order, peers } = getState();\n    const nextIndex = order.indexOf(myId) + 1;\n    const nextId = order[nextIndex];\n    return peers[nextId];\n}\n\nlet latencies = [];\n// This starts a series of pings that lasts from standby until recording starts\n// to get an idea of the latencies between each connection in the cascade.\n// We use it later to stitch together the video.\nexport function gatherLatencyInfo() {\n    latencies = [];\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        pingPeer(nextPeer);\n    }\n}\n\nfunction pingPeer(peer) {\n    peer.send(JSON.stringify({\n        type      : 'ping',\n        startTime : Date.now()\n    }));\n}\n\nfunction printLatencyInfo(latencyInfo) {\n    const { myId, order } = getState();\n    const { avgPingTime, fromId, numPings, stdDevPingTime, toId } = latencyInfo;\n    const fromOrderNumber = order.indexOf(fromId);\n    const toOrderNumber = order.indexOf(toId);\n    console.log(`latency info from ${fromOrderNumber} to ${toOrderNumber}:`);\n    console.log(`num pings = ${numPings};\n                 std dev = ${stdDevPingTime};\n                 avg rount trip = ${avgPingTime};\n                 est. one-way = ${avgPingTime / 2}`);\n    if (fromId === myId) {\n        console.log(latencies);\n    }\n}\n\nexport function sendLatencyInfo() {\n    const { myId, order, peers } = getState();\n\n    // Don't send if you're the end of the cascade\n    if (!getNextPeer()) return;\n\n    const numPings = latencies.length;\n    const pingSum = latencies.reduce((accumulator, pingTime) => accumulator + pingTime, 0);\n    const avgPingTime = pingSum / numPings;\n    const sumOfSquares = latencies.reduce(\n        (accumulator, pingTime) => accumulator + Math.pow(pingTime - avgPingTime, 2),\n        0\n    );\n    const stdDevPingTime = Math.sqrt(sumOfSquares / (numPings - 1));\n    const fromId = myId;\n    const toIndex = order.indexOf(myId) + 1;\n    const toId = order[toIndex];\n    const latencyInfo = {\n        type : 'latency_info',\n        avgPingTime,\n        fromId,\n        numPings,\n        stdDevPingTime,\n        toId\n    };\n\n    // For now, send info to the initiator to print, for manual slicing.\n    // Eventually, we want to send this to the server\n    // with the files to do the automatic syncing.\n    const initiatorId = order[0];\n    if (initiatorId === myId) {\n        printLatencyInfo(latencyInfo);\n    } else {\n        const initiator = peers[initiatorId];\n        initiator.send(JSON.stringify(latencyInfo));\n    }\n}\n","import { CASCADE_DONE, CASCADE_RECORDING, CASCADE_STANDBY } from './modes';\nimport { gatherLatencyInfo, getNextPeer, sendLatencyInfo } from './peer-actions';\nimport { getState, serverSend } from './reducer';\n\nfunction cloneTracks(stream) {\n    return stream.getTracks().map((track) => track.clone());\n}\n\nexport function cloneMyStream() {\n    const { myStream } = getState();\n    const tracks = cloneTracks(myStream);\n    return new MediaStream(tracks);\n}\n\nexport function startCascade(dispatch) {\n    const { myId } = getState();\n    // dispatch MODE_SET and broadcast via server\n    // (server will set lock on new participants)\n    const mode = CASCADE_STANDBY;\n    const action = {\n        type   : 'MODE_SET',\n        fromId : myId,\n        mode\n    };\n    changeMode(mode, dispatch);\n    serverSend(action);\n}\n\nexport function changeMode(newMode, dispatch) {\n    dispatch({\n        type : 'MODE_SET',\n        mode : newMode\n    });\n\n    const { recorder } = getState();\n\n    switch (newMode) {\n        case CASCADE_STANDBY:\n            stopStreaming();\n            gatherLatencyInfo();\n            break;\n        case CASCADE_RECORDING:\n            sendCascadeStream();\n            recorder.start();\n            break;\n        case CASCADE_DONE:\n            recorder.stop();\n            resetStreams();\n            sendLatencyInfo();\n            break;\n        default:\n    }\n}\n\nfunction stopStreaming() {\n    const { peers } = getState();\n    Object.values(peers).forEach((peer) => {\n        peer.removeStream(peer.streams[0]);\n    });\n}\n\nfunction sendCascadeStream() {\n    const { myId, myStream, order, streams } = getState();\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        const myIndex = order.indexOf(myId);\n        const myTracks = cloneTracks(myStream);\n        const otherTracks = order.slice(0, myIndex).reduce((accumulator, id) => {\n            return [\n                ...accumulator,\n                ...streams[id].getTracks()\n            ];\n        }, []);\n        const tracks = [\n            ...otherTracks,\n            ...myTracks\n        ];\n        // TODO: how to provide order?\n        // Maybe could peer.addTrack() one by one in order?\n        // Is that guaranteed to be received in the same order?\n        // Will there be A/V sync issues?\n        // Let's keep it TODO til we absolutely need do.\n        const cascadeStream = new MediaStream(tracks);\n        nextPeer.addStream(cascadeStream);\n    }\n}\n\nexport function setStreamsFromCascade(cascade, dispatch) {\n    const { myId, order } = getState();\n    const audioTracks = cascade.getAudioTracks();\n    const videoTracks = cascade.getVideoTracks();\n    const myIndex = order.indexOf(myId);\n    const beforeIds = order.slice(0, myIndex);\n    // For now, combine randomly\n    beforeIds.forEach((id, index) => {\n        const tracks = [\n            audioTracks[index],\n            videoTracks[index]\n        ].filter(Boolean);\n        if (tracks.length !== 2) {\n            console.error('Missing a track in the cascade');\n        }\n        dispatch({\n            type   : 'STREAMS_ADD',\n            id,\n            stream : new MediaStream(tracks)\n        });\n    });\n}\n\nfunction resetStreams() {\n    const { myId, order, peers } = getState();\n\n    // Adding the same MediaStream again causes an error\n    // so we have to clone the tracks\n    // and wrap them in a new MediaStream\n    const newMyStream = cloneMyStream();\n\n    // Signal to the next one it's done\n    const nextPeer = getNextPeer();\n    if (nextPeer) {\n        nextPeer.removeStream(nextPeer.streams[0]);\n        nextPeer.addStream(newMyStream);\n    }\n\n    // Send live video back to everyone upstream\n    const myIndex = order.indexOf(myId);\n    const beforeIds = order.slice(0, myIndex);\n    beforeIds.forEach((id) => {\n        const peer = peers[id];\n        peer.addStream(newMyStream);\n    });\n}\n\nexport function stopCascade(dispatch) {\n    changeMode(CASCADE_DONE, dispatch);\n}\n","import React, { useContext, useEffect, useState } from 'react';\nimport { Context } from '../Store';\nimport { changeMode } from '../../state/cascade-actions';\nimport { CASCADE_RECORDING } from '../../state/modes';\n\nconst Countdown = () => {\n    const [, dispatch] = useContext(Context);\n    const [number, setNumber] = useState(3);\n    useEffect(() => {\n        if (number > 0) {\n            setTimeout(() => {\n                setNumber(number - 1);\n            }, 2000);\n        } else {\n            changeMode(CASCADE_RECORDING, dispatch);\n        }\n    }, [number]);\n    return <span className=\"countdown\">{number}</span>\n};\n\nexport default Countdown;\n","import { useEffect, useRef } from 'react';\n\nexport default function usePrevious(value) {\n    const prevRef = useRef();\n    useEffect(() => {\n        prevRef.current = value;\n    }, [value]);\n    return prevRef.current;\n}\n","import React, { useCallback, useContext, useRef } from 'react';\nimport { useDrag, useDrop } from 'react-dnd';\nimport AudioVideoSetup from './AudioVideoSetup';\nimport Countdown from './Countdown';\nimport { Context } from '../Store';\nimport { CASCADE_DONE, CASCADE_RECORDING, CASCADE_STANDBY, READY } from '../../state/modes';\nimport { serverSend } from '../../state/reducer';\nimport usePrevious from '../../state/use-previous';\n\nconst VideoSquare = ({ id, numColumns, stream }) => {\n    const [state, dispatch] = useContext(Context);\n    const { audioOutput, iAmInitiator, mode, myId, order } = state;\n    const isMe = id === myId;\n    const prevStream = usePrevious(stream);\n    const prevAudioOutput = usePrevious(audioOutput);\n\n    const videoRef = useCallback((node) => {\n        if (node) {\n            if (stream !== prevStream) {\n                if ('srcObject' in node) {\n                    node.srcObject = stream;\n                } else {\n                    node.src = URL.createObjectURL(stream);\n                }\n            }\n\n            if (audioOutput && audioOutput !== prevAudioOutput) {\n                // TODO: check if available, alert user if not\n                // (Firefox needs setting enabled)\n                // (Safari is ?)\n                node.setSinkId(audioOutput);\n            }\n        }\n    }, [audioOutput, stream]);\n\n    const dndRef = useRef(null);\n    const [{ isDragging }, connectDrag] = useDrag({\n        item    : { id, type : 'participant' },\n        canDrag : () => iAmInitiator && [READY, CASCADE_DONE].includes(mode),\n        collect : (monitor) => ({ isDragging : monitor.isDragging() })\n    });\n    const [, connectDrop] = useDrop({\n        accept : 'participant',\n        drop   : (item) => {\n            serverSend({\n                type   : 'ORDER_SET',\n                fromId : myId,\n                order,\n            });\n        },\n        hover  : ({ id : hoveredOverId }) => {\n            if (hoveredOverId !== id) {\n                const myIndex = order.indexOf(id);\n                const theirIndex = order.indexOf(hoveredOverId);\n                const newOrder = [...order];\n                newOrder[myIndex] = hoveredOverId;\n                newOrder[theirIndex] = id;\n                dispatch({\n                    type  : 'ORDER_SET',\n                    order : newOrder\n                });\n            }\n        }\n    });\n    connectDrag(dndRef);\n    connectDrop(dndRef);\n\n    const orderNumber = mode === CASCADE_STANDBY ? 1 : order.indexOf(id) + 1;\n    const row = Math.ceil(orderNumber / numColumns);\n    const numBeforeRow = (row - 1) * numColumns;\n    const col = orderNumber - numBeforeRow;\n    const gridStyle = {\n        gridColumn : `${col} / span 1`,\n        gridRow    : `${row} / span 1`,\n        opacity    : isDragging ? 0.5 : 1,\n    };\n    const orderNumberStyle = {\n        backgroundColor : mode === CASCADE_STANDBY ? 'yellow' : (\n            mode === CASCADE_RECORDING ? 'red' : 'green'\n        )\n    };\n\n    return (\n        <div ref={dndRef} className=\"video-draggable\" style={gridStyle}>\n            { stream && <video autoPlay muted={isMe} ref={videoRef} /> }\n            { isMe && <AudioVideoSetup /> }\n            { orderNumber > 0 &&\n                <span className=\"order-number\" style={orderNumberStyle}>{orderNumber}</span> }\n            { mode === CASCADE_STANDBY && isMe && iAmInitiator &&\n                <Countdown /> }\n        </div>\n    );\n};\n\nexport default VideoSquare;\n","import React from 'react';\n\nconst Welcome = ({ onClick }) => {\n    return <>\n        <div>Welcome. Let's make the connections.</div>\n        <div>First, enable your audio and video. Before you click the button, put on headphones so there's no feedback!</div>\n        <button onClick={onClick}>\n            Let's go!\n        </button>\n    </>;\n};\n\nexport default Welcome;\n","import React, { useContext, useState } from 'react';\nimport { Context } from './Store';\nimport VideoSquare from './VideoSquare';\nimport Welcome from './Welcome';\nimport { startCascade, stopCascade } from '../state/cascade-actions';\nimport { CASCADE_DONE, CASCADE_RECORDING, READY } from '../state/modes';\n\nconst GreenRoom = () => {\n    const [state, dispatch] = useContext(Context);\n    console.log('STATE', state);\n    const { files, iAmInitiator, mode, myId, myStream, streams } = state;\n    const [showWelcome, setShowWelcome] = useState(true);\n\n    if (showWelcome) {\n        return <Welcome onClick={() => setShowWelcome(false)} />;\n    }\n\n    const numParticipants = Object.values(streams).length + 1;\n    // Add a new row when the number of participants exceeds the perfect square\n    // (2-4 partcipants have two columns, 5-9 have three columns, 10-16 have four columns, etc)\n    const cols = Math.ceil(Math.sqrt(numParticipants));\n    const rows = Math.ceil(numParticipants / cols);\n    const colPct = 100 / cols;\n    const rowPct = 100 / rows;\n    const gridStyles = {\n        gridTemplateColumns : `repeat(${cols}, ${colPct}%)`,\n        gridTemplateRows    : `repeat(${cols}, ${rowPct}%)`,\n    };\n\n    return <>\n        <main className=\"video-grid\" style={gridStyles}>\n            <VideoSquare id={myId} numColumns={cols} stream={myStream} />\n            { Object.entries(streams).map(([id, stream]) =>\n                <VideoSquare key={id} id={id} numColumns={cols} stream={stream} />\n            ) }\n        </main>\n        <nav>\n            { [READY, CASCADE_DONE].includes(mode) && iAmInitiator && numParticipants > 1 &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => startCascade(dispatch)}\n                >\n                    GO\n                </button> }\n            { mode === CASCADE_RECORDING && iAmInitiator &&\n                <button\n                    className=\"big-button\"\n                    onClick={() => stopCascade(dispatch)}\n                >\n                    STOP\n                </button> }\n        </nav>\n        <aside>\n            { files.map((blobURL, index) =>\n                <a\n                    key={blobURL}\n                    download={`cascade${index + 1}.webm`}\n                    href={blobURL}\n                >\n                    Download cascade {index + 1} video\n                </a>) }\n        </aside>\n    </>;\n};\n\nexport default GreenRoom;\n","import { useContext, useEffect } from 'react';\nimport { Context } from './Store';\nimport { changeMode } from '../state/cascade-actions';\nimport { checkForNewPeers, handlePeerSignal } from '../state/peer-actions';\nimport usePrevious from '../state/use-previous';\n\nconst ServerProvider = ({ children }) => {\n    const [state, dispatch] = useContext(Context);\n    const { myStream } = state;\n    const prevMyStream = usePrevious(myStream);\n    const params = new URLSearchParams(window.location.search);\n    const serverURL = params.get('server');\n    useEffect(() => {\n        // Start the server connection only when myStream is first initiated\n        if (myStream && !prevMyStream && serverURL) {\n            // We set the server connection here because\n            // we need access to dispatch in the event listeners.\n            const server = new WebSocket(serverURL);\n            server.addEventListener('open', () => console.log('opening socket'));\n            // TODO: handle failed connection\n            server.addEventListener('close', () => console.log('closing socket'));\n            server.addEventListener('error', () => console.log('socket error'));\n            server.addEventListener('message', ({ data }) => {\n                const action = JSON.parse(data);\n                console.log('ACTION (from server):', action);\n                // Some actions have side effects and should only happen once.\n                // (a single dispatch can call the reducer multiple times)\n                switch (action.type) {\n                    case 'MODE_SET':\n                        changeMode(action.mode, dispatch);\n                        break;\n                    case 'ORDER_SET':\n                        checkForNewPeers(action, dispatch);\n                        break;\n                    case 'PEER_SIGNAL':\n                        handlePeerSignal(action, dispatch);\n                        break;\n                    default:\n                        // Otherwise, messages from the server\n                        // are simply actions for the reducer.\n                        dispatch(action);\n                }\n            });\n            dispatch({\n                type : 'SERVER_SET',\n                server\n            });\n        }\n    }, [myStream, prevMyStream, serverURL]);\n\n    if (!serverURL) {\n        return \"You have to have a server. Sorry, that's just the way it is.\";\n    }\n\n    return children;\n};\n\nexport default ServerProvider;\n","import React from 'react';\nimport { DndProvider } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport GreenRoom from './GreenRoom';\nimport ServerProvider from './ServerProvider';\nimport Store from './Store';\nimport './App.css';\n\nconst App = () => {\n    // TODO: Splash to explain what it is, button to enter green room.\n    return (\n        <Store>\n            <ServerProvider>\n                <DndProvider backend={HTML5Backend}>\n                    <GreenRoom />\n                </DndProvider>\n            </ServerProvider>\n        </Store>\n    );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}