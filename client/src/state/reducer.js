import { CASCADE_DONE, CASCADE_STANDBY, READY, SETUP } from './modes';
import { makeNewRecorder } from './actions/recording';

export const initialState = {
    // This needs to be stored here so all video elements output sound to the same place.
    audioOutput   : null,
    // Blob URLs of the recorded myStream (not combined with other peers)
    files         : [],
    // The initiator is whoever is in the first spot.
    // They have all the power. They get to rearrange the order of the cascade.
    // And they press the big GO button.
    iAmInitiator  : false,
    mode          : SETUP,
    // UUID generated by the server
    myId          : null,
    // MediaStream object containing audio/video
    myStream      : null,
    // The order of the participants - how the audios cascades
    order         : [],
    // Direct connections to other participants via WebRTC that provide the streams
    // Keys are the server-generated IDs
    peers         : {},
    // Records myStream during cascade
    recorder      : null,
    // WebSocket server connection to send the initial WebRTC signals (and a biiiit more after)
    server        : null,
    // MediaStream objects for remote peers
    // Keys are the server-generated IDs
    streams       : {}
};

function reducer(state, action) {
    console.log('ACTION', action);
    const { files, mode, myId, myStream, order, peers, streams } = state;
    switch (action.type) {
        case 'AUDIO_OUTPUT_SET':
            return {
                ...state,
                audioOutput : action.deviceId
            };
        case 'FILES_ADD':
            return {
                ...state,
                files : files.concat(action.file)
            };
        case 'MODE_SET': {
            const { mode : newMode } = action;
            // When starting or ending the cascade, remove all streams except
            // the prev one (they will be stopped shortly)
            let newStreams = streams;
            if (newMode === CASCADE_STANDBY || newMode === CASCADE_DONE) {
                newStreams = {};
                const myIndex = order.indexOf(myId);
                const prevId = order[myIndex - 1];
                if (prevId) {
                    newStreams[prevId] = streams[prevId];
                }
            }
            return {
                ...state,
                mode    : newMode,
                streams : newStreams
            };
        }
        case 'MY_ID_SET':
            return {
                ...state,
                myId : action.id
            };
        case 'MY_STREAM_SET': {
            // Move from setup mode when myStream is first set
            const newMode = myStream ? mode : READY;
            return {
                ...state,
                mode     : newMode,
                myStream : action.stream,
                recorder : makeNewRecorder(action.stream, action.dispatch)
            };
        }
        case 'ORDER_SET': {
            const { order : newOrder } = action;
            const myOrderIndex = newOrder.findIndex((otherId) => myId === otherId);
            const iAmInitiator = myOrderIndex === 0;
            // If an id has been taken away from the order, remove the peers and streams
            const [newPeers, newStreams] = newOrder.reduce((accumulator, id) => {
                if (id === myId) return accumulator;
                return [
                    {
                        ...accumulator[0],
                        [id] : peers[id]
                    },
                    {
                        ...accumulator[1],
                        [id] : streams[id]
                    }
                ]
            }, [{}, {}]);
            return {
                ...state,
                iAmInitiator,
                order   : newOrder,
                peers   : newPeers,
                streams : newStreams
            };
        }
        case 'PEERS_ADD':
            return {
                ...state,
                peers : {
                    ...peers,
                    [action.id] : action.peer
                }
            };
        case 'SERVER_SET':
            return {
                ...state,
                server : action.server
            };
        case 'STREAMS_ADD':
            return {
                ...state,
                streams : {
                    ...streams,
                    [action.id] : action.stream
                }
            };
        case 'STREAMS_REMOVE': {
            const newStreams = { ...streams };
            delete newStreams[action.id];
            return {
                ...state,
                streams : newStreams
            };
        }
        default: {
            console.error('Unknown action:', action);
            return state;
        }
    }
};

let evilBoogiemanGlobalState = {};
export function getState() {
    return evilBoogiemanGlobalState;
}

export default function reduceAndSave(state, action) {
    const newState = reducer(state, action);
    evilBoogiemanGlobalState = newState;
    return newState;
}
